<!DOCTYPE html>
<html lang="en">
<head>

    <title>AgentTesla - Full Loader Analysis - Resolving API Hashes Using Conditional Breakpoints</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <link rel="preload" as="style" href="/assets/built/screen.css?v=4b294bb165">
    <link rel="preload" as="script" href="/assets/built/source.js?v=4b294bb165">

    <link rel="stylesheet" type="text/css" href="/assets/built/screen.css?v=4b294bb165">

    <style>
        :root {
            --background-color: #000000
        }
    </style>

    <script>
        /* The script for calculating the color contrast has been taken from
        https://gomakethings.com/dynamically-changing-the-text-color-based-on-background-color-contrast-with-vanilla-js/ */
        var accentColor = getComputedStyle(document.documentElement).getPropertyValue('--background-color');
        accentColor = accentColor.trim().slice(1);
        var r = parseInt(accentColor.substr(0, 2), 16);
        var g = parseInt(accentColor.substr(2, 2), 16);
        var b = parseInt(accentColor.substr(4, 2), 16);
        var yiq = ((r * 299) + (g * 587) + (b * 114)) / 1000;
        var textColor = (yiq >= 128) ? 'dark' : 'light';

        document.documentElement.className = `has-${textColor}-text`;
    </script>

    <meta name="description" content="Analysis of a Multi-Stage Loader for AgentTesla. Covering Ghidra, Dnspy, X32dbg, API Hashing and more!">
    <link rel="icon" href="https://embee-research.ghost.io/content/images/size/w256h256/format/png/2023/11/logo.svg.svg" type="image/png">
    <link rel="canonical" href="https://embee-research.ghost.io/agenttesla-full-analysis-api-hashing/">
    <meta name="referrer" content="no-referrer-when-downgrade">
    
    <meta property="og:site_name" content="Embee Research">
    <meta property="og:type" content="article">
    <meta property="og:title" content="AgentTesla - Full Loader Analysis - Resolving API Hashes Using Conditional Breakpoints">
    <meta property="og:description" content="Analysis of a Multi-Stage Loader for AgentTesla. Covering Ghidra, Dnspy, X32dbg, API Hashing and more!">
    <meta property="og:url" content="https://embee-research.ghost.io/agenttesla-full-analysis-api-hashing/">
    <meta property="og:image" content="https://embee-research.ghost.io/content/images/2023/05/DALL-E-2023-04-21-23.42.56---A-1920-s-Noir-Investigative-Police-Officer---He-is-Angry-and-Screaming-at-the-Sky-as-Lightning-shoots-out-of-his-Body-in-all-directions---Dark-Mood---.png">
    <meta property="article:published_time" content="2023-05-07T09:48:03.000Z">
    <meta property="article:modified_time" content="2023-11-15T08:14:18.000Z">
    <meta property="article:tag" content="Advanced">
    <meta property="article:tag" content="Debugger Tutorials">
    <meta property="article:tag" content="Malware Analysis With Dnspy">
    <meta property="article:tag" content="Ghidra Tutorials">
    <meta property="article:tag" content="All Content">
    <meta property="article:tag" content="Reverse Engineering">
    
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="AgentTesla - Full Loader Analysis - Resolving API Hashes Using Conditional Breakpoints">
    <meta name="twitter:description" content="Analysis of a Multi-Stage Loader for AgentTesla. Covering Ghidra, Dnspy, X32dbg, API Hashing and more!">
    <meta name="twitter:url" content="https://embee-research.ghost.io/agenttesla-full-analysis-api-hashing/">
    <meta name="twitter:image" content="https://embee-research.ghost.io/content/images/2023/05/DALL-E-2023-04-21-23.42.56---A-1920-s-Noir-Investigative-Police-Officer---He-is-Angry-and-Screaming-at-the-Sky-as-Lightning-shoots-out-of-his-Body-in-all-directions---Dark-Mood---.png">
    <meta name="twitter:label1" content="Written by">
    <meta name="twitter:data1" content="Matthew">
    <meta name="twitter:label2" content="Filed under">
    <meta name="twitter:data2" content="Advanced, Debugger Tutorials, Malware Analysis With Dnspy, Ghidra Tutorials, All Content, Reverse Engineering">
    <meta name="twitter:site" content="@embee_research">
    <meta name="twitter:creator" content="@embee_research">
    <meta property="og:image:width" content="1024">
    <meta property="og:image:height" content="1024">
    
    <script type="application/ld+json">
{
    "@context": "https://schema.org",
    "@type": "Article",
    "publisher": {
        "@type": "Organization",
        "name": "Embee Research",
        "url": "https://embee-research.ghost.io/",
        "logo": {
            "@type": "ImageObject",
            "url": "https://embee-research.ghost.io/content/images/2023/11/logo.svg-1.svg",
            "width": 60,
            "height": 60
        }
    },
    "author": {
        "@type": "Person",
        "name": "Matthew",
        "url": "https://embee-research.ghost.io/author/matthew/",
        "sameAs": [
            "https://twitter.com/embee_research"
        ]
    },
    "headline": "AgentTesla - Full Loader Analysis - Resolving API Hashes Using Conditional Breakpoints",
    "url": "https://embee-research.ghost.io/agenttesla-full-analysis-api-hashing/",
    "datePublished": "2023-05-07T09:48:03.000Z",
    "dateModified": "2023-11-15T08:14:18.000Z",
    "image": {
        "@type": "ImageObject",
        "url": "https://embee-research.ghost.io/content/images/2023/05/DALL-E-2023-04-21-23.42.56---A-1920-s-Noir-Investigative-Police-Officer---He-is-Angry-and-Screaming-at-the-Sky-as-Lightning-shoots-out-of-his-Body-in-all-directions---Dark-Mood---.png",
        "width": 1024,
        "height": 1024
    },
    "keywords": "Advanced, Debugger Tutorials, Malware Analysis With Dnspy, Ghidra Tutorials, All Content, Reverse Engineering",
    "description": "Analysis of a Multi-Stage Loader for AgentTesla. Covering Ghidra, Dnspy, X32dbg, API Hashing and more!",
    "mainEntityOfPage": "https://embee-research.ghost.io/agenttesla-full-analysis-api-hashing/"
}
    </script>

    <meta name="generator" content="Ghost 5.75">
    <link rel="alternate" type="application/rss+xml" title="Embee Research" href="https://embee-research.ghost.io/rss/">
    <script defer src="https://cdn.jsdelivr.net/ghost/portal@~2.36/umd/portal.min.js" data-i18n="false" data-ghost="https://embee-research.ghost.io/" data-key="5b00360b75171de09d2f740e1c" data-api="https://embee-research.ghost.io/ghost/api/content/" crossorigin="anonymous"></script><style id="gh-members-styles">.gh-post-upgrade-cta-content,
.gh-post-upgrade-cta {
    display: flex;
    flex-direction: column;
    align-items: center;
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
    text-align: center;
    width: 100%;
    color: #ffffff;
    font-size: 16px;
}

.gh-post-upgrade-cta-content {
    border-radius: 8px;
    padding: 40px 4vw;
}

.gh-post-upgrade-cta h2 {
    color: #ffffff;
    font-size: 28px;
    letter-spacing: -0.2px;
    margin: 0;
    padding: 0;
}

.gh-post-upgrade-cta p {
    margin: 20px 0 0;
    padding: 0;
}

.gh-post-upgrade-cta small {
    font-size: 16px;
    letter-spacing: -0.2px;
}

.gh-post-upgrade-cta a {
    color: #ffffff;
    cursor: pointer;
    font-weight: 500;
    box-shadow: none;
    text-decoration: underline;
}

.gh-post-upgrade-cta a:hover {
    color: #ffffff;
    opacity: 0.8;
    box-shadow: none;
    text-decoration: underline;
}

.gh-post-upgrade-cta a.gh-btn {
    display: block;
    background: #ffffff;
    text-decoration: none;
    margin: 28px 0 0;
    padding: 8px 18px;
    border-radius: 4px;
    font-size: 16px;
    font-weight: 600;
}

.gh-post-upgrade-cta a.gh-btn:hover {
    opacity: 0.92;
}</style><script async src="https://js.stripe.com/v3/"></script>
    <script defer src="https://cdn.jsdelivr.net/ghost/sodo-search@~1.1/umd/sodo-search.min.js" data-key="5b00360b75171de09d2f740e1c" data-styles="https://cdn.jsdelivr.net/ghost/sodo-search@~1.1/umd/main.css" data-sodo-search="https://embee-research.ghost.io/" crossorigin="anonymous"></script>
    <script defer src="https://cdn.jsdelivr.net/ghost/announcement-bar@~1.1/umd/announcement-bar.min.js" data-announcement-bar="https://embee-research.ghost.io/" data-api-url="https://embee-research.ghost.io/members/api/announcement/" crossorigin="anonymous"></script>
    <link href="https://embee-research.ghost.io/webmentions/receive/" rel="webmention">
    <script defer src="/public/cards.min.js?v=4b294bb165"></script>
    <link rel="stylesheet" type="text/css" href="/public/cards.min.css?v=4b294bb165">
    <script defer src="/public/member-attribution.min.js?v=4b294bb165"></script>
    <script defer data-domain="embee-research.ghost.io" src="https://plausible.io/js/plausible.js"></script>
<style>:root {--ghost-accent-color: #5b00a6;}</style>

</head>
<body class="post-template tag-advanced tag-debugging tag-dotnetmalware tag-ghidra tag-blog tag-reversing has-sans-title has-sans-body">

<div class="gh-viewport">
    
    <header id="gh-navigation" class="gh-navigation is-stacked gh-outer">
    <div class="gh-navigation-inner gh-inner">

        <div class="gh-navigation-brand">
            <a class="gh-navigation-logo is-title" href="https://embee-research.ghost.io">
                    <img src="https://embee-research.ghost.io/content/images/2023/11/logo.svg-1.svg" alt="Embee Research">
            </a>
            <button class="gh-search gh-icon-button" aria-label="Search this site" data-ghost-search>
    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2" width="20" height="20"><path stroke-linecap="round" stroke-linejoin="round" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z"></path></svg></button>            <button class="gh-burger gh-icon-button">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="currentColor" viewBox="0 0 256 256"><path d="M224,128a8,8,0,0,1-8,8H40a8,8,0,0,1,0-16H216A8,8,0,0,1,224,128ZM40,72H216a8,8,0,0,0,0-16H40a8,8,0,0,0,0,16ZM216,184H40a8,8,0,0,0,0,16H216a8,8,0,0,0,0-16Z"></path></svg>                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="currentColor" viewBox="0 0 256 256"><path d="M205.66,194.34a8,8,0,0,1-11.32,11.32L128,139.31,61.66,205.66a8,8,0,0,1-11.32-11.32L116.69,128,50.34,61.66A8,8,0,0,1,61.66,50.34L128,116.69l66.34-66.35a8,8,0,0,1,11.32,11.32L139.31,128Z"></path></svg>            </button>
        </div>

        <nav class="gh-navigation-menu">
            <ul class="nav">
    <li class="nav-home"><a href="https://embee-research.ghost.io/">Home</a></li>
    <li class="nav-reverse-engineering"><a href="https://embee-research.ghost.io/tag/reversing/">Reverse Engineering</a></li>
    <li class="nav-detection-engineering"><a href="https://embee-research.ghost.io/tag/detection/">Detection Engineering</a></li>
    <li class="nav-threat-intelligence"><a href="https://embee-research.ghost.io/tag/intel/">Threat Intelligence</a></li>
    <li class="nav-ghidra-tutorials"><a href="https://embee-research.ghost.io/tag/ghidra/">Ghidra Tutorials</a></li>
    <li class="nav-testimonials"><a href="https://embee-research.ghost.io/testimonials/">Testimonials</a></li>
</ul>

        </nav>

        <div class="gh-navigation-actions">
                <button class="gh-search gh-icon-button" aria-label="Search this site" data-ghost-search>
    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2" width="20" height="20"><path stroke-linecap="round" stroke-linejoin="round" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z"></path></svg></button>                <div class="gh-navigation-members">
                            <a href="#/portal/signin" data-portal="signin">Sign in</a>
                                <a class="gh-button" href="#/portal/signup" data-portal="signup">Subscribe</a>
                </div>
        </div>

    </div>
</header>

    

<main class="gh-main">

    <article class="gh-article post tag-advanced tag-debugging tag-dotnetmalware tag-ghidra tag-blog tag-reversing featured">

        <header class="gh-article-header gh-canvas">

                <a class="gh-article-tag" href="https://embee-research.ghost.io/tag/advanced/">Advanced</a>
            <h1 class="gh-article-title is-title">AgentTesla - Full Loader Analysis - Resolving API Hashes Using Conditional Breakpoints</h1>
                <p class="gh-article-excerpt is-body">Analysis of a Multi-Stage Loader for AgentTesla. Covering Ghidra, Dnspy, X32dbg, API Hashing and more!</p>

            <div class="gh-article-meta">
                <div class="gh-article-author-image">
                            <a href="/author/matthew/"><svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><g fill="none" fill-rule="evenodd"><path d="M3.513 18.998C4.749 15.504 8.082 13 12 13s7.251 2.504 8.487 5.998C18.47 21.442 15.417 23 12 23s-6.47-1.558-8.487-4.002zM12 12c2.21 0 4-2.79 4-5s-1.79-4-4-4-4 1.79-4 4 1.79 5 4 5z" fill="#FFF"/></g></svg>
</a>
                </div>
                <div class="gh-article-meta-wrapper">
                    <h4 class="gh-article-author-name"><a href="/author/matthew/">Matthew</a></h4>
                    <div class="gh-article-meta-content">
                        <time class="gh-article-meta-date" datetime="2023-05-07">May 7, 2023</time>
                            <span class="gh-article-meta-length"><span class="bull">—</span> 29 min read</span>
                    </div>
                </div>
            </div>

                <figure class="gh-article-image">
        <img
            srcset="/content/images/size/w320/2023/05/DALL-E-2023-04-21-23.42.56---A-1920-s-Noir-Investigative-Police-Officer---He-is-Angry-and-Screaming-at-the-Sky-as-Lightning-shoots-out-of-his-Body-in-all-directions---Dark-Mood---.png 320w,
                    /content/images/size/w600/2023/05/DALL-E-2023-04-21-23.42.56---A-1920-s-Noir-Investigative-Police-Officer---He-is-Angry-and-Screaming-at-the-Sky-as-Lightning-shoots-out-of-his-Body-in-all-directions---Dark-Mood---.png 600w,
                    /content/images/size/w960/2023/05/DALL-E-2023-04-21-23.42.56---A-1920-s-Noir-Investigative-Police-Officer---He-is-Angry-and-Screaming-at-the-Sky-as-Lightning-shoots-out-of-his-Body-in-all-directions---Dark-Mood---.png 960w,
                    /content/images/size/w1200/2023/05/DALL-E-2023-04-21-23.42.56---A-1920-s-Noir-Investigative-Police-Officer---He-is-Angry-and-Screaming-at-the-Sky-as-Lightning-shoots-out-of-his-Body-in-all-directions---Dark-Mood---.png 1200w,
                    /content/images/size/w2000/2023/05/DALL-E-2023-04-21-23.42.56---A-1920-s-Noir-Investigative-Police-Officer---He-is-Angry-and-Screaming-at-the-Sky-as-Lightning-shoots-out-of-his-Body-in-all-directions---Dark-Mood---.png 2000w"
            src="/content/images/size/w1200/2023/05/DALL-E-2023-04-21-23.42.56---A-1920-s-Noir-Investigative-Police-Officer---He-is-Angry-and-Screaming-at-the-Sky-as-Lightning-shoots-out-of-his-Body-in-all-directions---Dark-Mood---.png"
            alt="AgentTesla - Full Loader Analysis - Resolving API Hashes Using Conditional Breakpoints"
        >
    </figure>

        </header>

        <section class="gh-content gh-canvas is-body">
            <h1 id></h1><p><strong>Summary:</strong></p><p>This article covers the Analysis of a multi-stage AgentTesla loader. The loader utilizes a Nullsoft package to drop an exe-based loader and multiple encrypted files. We'll follow the loader as it locates and decrypts the encrypted files, ultimately resulting in Shellcode which deploys AgentTesla malware.</p><p><strong>Topics Covered:</strong></p><ul><li>Initial Analysis of Nullsoft File</li><li>Extraction of exe and encrypted files.</li><li>Static Analysis of exe using Ghidra.</li><li>Static Analysis of Shellcode Using Ghidra</li><li>Identification of Stack Strings</li><li>Identification of API hashing</li><li>X32dbg for Decoding Individual hashed APIs</li><li>x32dbg for Decoding API Hashes in Bulk</li></ul><p><strong>Sha256:</strong> 7512be2746137d9694e3ec3a83e8ab4c6e4d826798a04381de53d4c6973d519f</p><p><strong>Link:</strong> <a href="https://bazaar.abuse.ch/sample/7512be2746137d9694e3ec3a83e8ab4c6e4d826798a04381de53d4c6973d519f/?ref=embee-research.ghost.io">https://bazaar.abuse.ch/sample/7512be2746137d9694e3ec3a83e8ab4c6e4d826798a04381de53d4c6973d519f/</a></p><h1 id="primary-analysis">Primary Analysis</h1><p>After unpacking the initial .zip <code>pw:infected</code> - An .exe is obtained.  </p><figure class="kg-card kg-image-card"><img src="https://embee-research.ghost.io/content/images/2023/04/image-186.png" class="kg-image" alt="https://embee-research.ghost.io/content/images/2023/04/image-186.png" loading="lazy" width="1796" height="262" srcset="https://embee-research.ghost.io/content/images/size/w600/2023/04/image-186.png 600w, https://embee-research.ghost.io/content/images/size/w1000/2023/04/image-186.png 1000w, https://embee-research.ghost.io/content/images/size/w1600/2023/04/image-186.png 1600w, https://embee-research.ghost.io/content/images/2023/04/image-186.png 1796w" sizes="(min-width: 720px) 720px"></figure><p>Using <code>detect-it-easy</code>, we can determine the file is packaged using the <a href="https://sourceforge.net/projects/nsis/?ref=embee-research.ghost.io">Nullsoft Scriptable Install System</a>. </p><figure class="kg-card kg-image-card"><img src="https://embee-research.ghost.io/content/images/2023/04/image-187.png" class="kg-image" alt="https://embee-research.ghost.io/content/images/2023/04/image-187.png" loading="lazy" width="1449" height="933" srcset="https://embee-research.ghost.io/content/images/size/w600/2023/04/image-187.png 600w, https://embee-research.ghost.io/content/images/size/w1000/2023/04/image-187.png 1000w, https://embee-research.ghost.io/content/images/2023/04/image-187.png 1449w" sizes="(min-width: 720px) 720px"></figure><p>My initial approach with any scriptable installer is to attempt to unzip the file. This is because most exe-based installer scripts are just a zip file with a small exe stub that unzips and executes the files.<br><br>Unzipping the folder using 7-zip reveals four files. Including a randomly named <code>cwlkewfbz.exe</code> and a Nullsoft Script <code>.nsi</code>.</p><p>My initial assumption here was that the <code>.nsi</code>script would execute the <code>cwlkewfbz.exe</code> file, so I decided to look into the script to see if this was true. </p><figure class="kg-card kg-image-card"><img src="https://embee-research.ghost.io/content/images/2023/04/image-188.png" class="kg-image" alt="https://embee-research.ghost.io/content/images/2023/04/image-188.png" loading="lazy" width="1509" height="281" srcset="https://embee-research.ghost.io/content/images/size/w600/2023/04/image-188.png 600w, https://embee-research.ghost.io/content/images/size/w1000/2023/04/image-188.png 1000w, https://embee-research.ghost.io/content/images/2023/04/image-188.png 1509w" sizes="(min-width: 720px) 720px"></figure><p>I assumed the script would be text-based and viewable with a text editor. So I used <a href="https://notepad-plus-plus.org/downloads/?ref=embee-research.ghost.io">Notepad++</a> to view it.</p><p>The initial parts (below) look like junk - but after a short scroll to line, a potential execution path and parameters of <code>cwlkewfbz.exe</code> can be observed.</p><p>It appears (lines 55,68) the <code>cwlkewfbz.exe</code> is intended to execute from the users <code>%TEMP%</code> folder with <code>pgkayd.aq</code> file as a parameter.</p><blockquote>This was interesting information and implied that the malware requires two "pieces" in order to function. In situations like this, generally the .exe is a loader, and the real malware is contained in an encrypted file passed as a parameter (in this case the <code>pgkayd.aq</code>)</blockquote><figure class="kg-card kg-image-card"><img src="https://embee-research.ghost.io/content/images/2023/04/image-189.png" class="kg-image" alt="https://embee-research.ghost.io/content/images/2023/04/image-189.png" loading="lazy" width="1327" height="578" srcset="https://embee-research.ghost.io/content/images/size/w600/2023/04/image-189.png 600w, https://embee-research.ghost.io/content/images/size/w1000/2023/04/image-189.png 1000w, https://embee-research.ghost.io/content/images/2023/04/image-189.png 1327w" sizes="(min-width: 720px) 720px"></figure><p>A review of the <code>pgkayd.aq</code> file using <code>detect-it-easy</code> revealed no recognized file formats, but the overall entropy was high. This suggested that <code>pgkayd.aq</code> might be encrypted or obfuscated.</p><blockquote>If a strong encryption was used, then the entropy would be flat and generally higher (usually around 7.9 for good encryption). This suggested a low-effort 0r low-quality encryption may be used.</blockquote><figure class="kg-card kg-image-card"><img src="https://embee-research.ghost.io/content/images/2023/04/image-190.png" class="kg-image" alt="https://embee-research.ghost.io/content/images/2023/04/image-190.png" loading="lazy" width="1527" height="1263" srcset="https://embee-research.ghost.io/content/images/size/w600/2023/04/image-190.png 600w, https://embee-research.ghost.io/content/images/size/w1000/2023/04/image-190.png 1000w, https://embee-research.ghost.io/content/images/2023/04/image-190.png 1527w" sizes="(min-width: 720px) 720px"></figure><p>I reviewed the file for any plaintext strings that may indicate its purpose. But this revealed only seven strings. None of which were helpful.</p><figure class="kg-card kg-image-card"><img src="https://embee-research.ghost.io/content/images/2023/04/image-191.png" class="kg-image" alt="https://embee-research.ghost.io/content/images/2023/04/image-191.png" loading="lazy" width="1528" height="1261" srcset="https://embee-research.ghost.io/content/images/size/w600/2023/04/image-191.png 600w, https://embee-research.ghost.io/content/images/size/w1000/2023/04/image-191.png 1000w, https://embee-research.ghost.io/content/images/2023/04/image-191.png 1528w" sizes="(min-width: 720px) 720px"></figure><p>Reviewing the other <code>djdqvq.sra</code> file within the folder, an extremely high (and flat) entropy is observed.</p><blockquote>The high and flat entropy strongly suggests that <code>djdqvq.sra</code> is encrypted.</blockquote><figure class="kg-card kg-image-card"><img src="https://embee-research.ghost.io/content/images/2023/04/image-192.png" class="kg-image" alt="https://embee-research.ghost.io/content/images/2023/04/image-192.png" loading="lazy" width="1523" height="1246" srcset="https://embee-research.ghost.io/content/images/size/w600/2023/04/image-192.png 600w, https://embee-research.ghost.io/content/images/size/w1000/2023/04/image-192.png 1000w, https://embee-research.ghost.io/content/images/2023/04/image-192.png 1523w" sizes="(min-width: 720px) 720px"></figure><h3 id="back-to-cwlkewfbzexe"><strong>Back to cwlkewfbz.exe</strong></h3><p>After a review of the <code>djdqvq.sra</code> and <code>pgkayd.aq</code> files revealed they were likely encrypted. I returned to the <code>cwlkewfbz.exe</code> file.</p><figure class="kg-card kg-image-card"><img src="https://embee-research.ghost.io/content/images/2023/04/image-193.png" class="kg-image" alt="https://embee-research.ghost.io/content/images/2023/04/image-193.png" loading="lazy" width="1442" height="922" srcset="https://embee-research.ghost.io/content/images/size/w600/2023/04/image-193.png 600w, https://embee-research.ghost.io/content/images/size/w1000/2023/04/image-193.png 1000w, https://embee-research.ghost.io/content/images/2023/04/image-193.png 1442w" sizes="(min-width: 720px) 720px"></figure><p>This reveals a  <code>C/C++</code> file with no significant areas of entropy.</p><blockquote>The lack of high entropy areas suggests that the file does not contain any embedded encrypted content.</blockquote><figure class="kg-card kg-image-card"><img src="https://embee-research.ghost.io/content/images/2023/04/image-194.png" class="kg-image" alt="https://embee-research.ghost.io/content/images/2023/04/image-194.png" loading="lazy" width="1522" height="1260" srcset="https://embee-research.ghost.io/content/images/size/w600/2023/04/image-194.png 600w, https://embee-research.ghost.io/content/images/size/w1000/2023/04/image-194.png 1000w, https://embee-research.ghost.io/content/images/2023/04/image-194.png 1522w" sizes="(min-width: 720px) 720px"></figure><p>Reviewing the imported functions reveals the usage of <code>VirtualAlloc</code> . This is a valuable function/API that we can later set a breakpoint on to extract information about allocated memory.</p><blockquote>Although VirtualAlloc has legitimate uses and is not malicious on its own - it also a common API used by malware to allocate new memory regions. The purpose of these regions is often to store decrypted payloads and additional stages of malware.</blockquote><figure class="kg-card kg-image-card"><img src="https://embee-research.ghost.io/content/images/2023/04/image-195.png" class="kg-image" alt="https://embee-research.ghost.io/content/images/2023/04/image-195.png" loading="lazy" width="1700" height="496" srcset="https://embee-research.ghost.io/content/images/size/w600/2023/04/image-195.png 600w, https://embee-research.ghost.io/content/images/size/w1000/2023/04/image-195.png 1000w, https://embee-research.ghost.io/content/images/size/w1600/2023/04/image-195.png 1600w, https://embee-research.ghost.io/content/images/2023/04/image-195.png 1700w" sizes="(min-width: 720px) 720px"></figure><p>Lastly, I used <code>detect-it-easy</code> to perform a string search on <code>cwlkewfbz.exe</code>. I had hoped that there might be strings that could indicate the purpose or origin of the Malware.</p><p>Sadly, the string search did not determine anything interesting, just a bunch of Windows and C++ library shenanigans.</p><h2 id="analyzing-cwlkewfbzexex32dbg">Analyzing cwlkewfbz.exe - x32dbg</h2><p> I decided to move beyond basic analysis. My approach Analysisse <a href="https://x64dbg.com/?ref=embee-research.ghost.io">x32dbg</a> to monitor the previously noted usage of  <code>VirtualAlloc</code></p><p>I hoped that this might reveal an additional payload or decrypted content.</p><p>I opened the <code>cwlkewfbz.exe</code> file in x32dbg and allowed it to execute until the initial entry point.</p><figure class="kg-card kg-image-card"><img src="https://embee-research.ghost.io/content/images/2023/04/image-197.png" class="kg-image" alt="https://embee-research.ghost.io/content/images/2023/04/image-197.png" loading="lazy" width="2000" height="848" srcset="https://embee-research.ghost.io/content/images/size/w600/2023/04/image-197.png 600w, https://embee-research.ghost.io/content/images/size/w1000/2023/04/image-197.png 1000w, https://embee-research.ghost.io/content/images/size/w1600/2023/04/image-197.png 1600w, https://embee-research.ghost.io/content/images/size/w2400/2023/04/image-197.png 2400w" sizes="(min-width: 720px) 720px"></figure><p>I then created a breakpoint on VirtualAlloc with <code>bp VirtualAlloc</code></p><figure class="kg-card kg-image-card"><img src="https://embee-research.ghost.io/content/images/2023/04/image-196.png" class="kg-image" alt="https://embee-research.ghost.io/content/images/2023/04/image-196.png" loading="lazy" width="543" height="134"></figure><p>I allowed the Malware to continue to execute.</p><p>However - the VirtualAlloc breakpoint was never hit and the process was immediately terminated.</p><figure class="kg-card kg-image-card"><img src="https://embee-research.ghost.io/content/images/2023/04/image-199.png" class="kg-image" alt="https://embee-research.ghost.io/content/images/2023/04/image-199.png" loading="lazy" width="1745" height="526" srcset="https://embee-research.ghost.io/content/images/size/w600/2023/04/image-199.png 600w, https://embee-research.ghost.io/content/images/size/w1000/2023/04/image-199.png 1000w, https://embee-research.ghost.io/content/images/size/w1600/2023/04/image-199.png 1600w, https://embee-research.ghost.io/content/images/2023/04/image-199.png 1745w" sizes="(min-width: 720px) 720px"></figure><p>Since the breakpoint on <code>VirtualAlloc</code> was never triggered; I knew something must have happened between the entry point and the Malware’s initial call to VirtualAlloc.</p><p>There are a few ways that this could be investigated</p><ul><li>Exit Breakpoint - Can be used to view the function that triggered the process termination,</li><li>Ghidra - To locate paths to VirtualAlloc and diagnose any potential issues, anti-debugging or similar.</li></ul><h2 id="static-analysis-using-ghidra">Static Analysis Using Ghidra</h2><p>After the initial breakpoint failed, I used <a href="https://ghidra-sre.org/?ref=embee-research.ghost.io">Ghidra</a> to gather more information about paths to <a href="https://learn.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-virtualalloc?ref=embee-research.ghost.io">VirtualAlloc</a>.</p><p>Since the breakpoint was not being hit at all - I wanted to use Ghidra to investigate any paths between the EntryPoint and <code>VirtualAlloc</code>.</p><blockquote>There are two main features that I'll use to achieve this</blockquote><p><strong>Cross References (x-refs)</strong> - To see where a given resource (function, API, string, etc) is used within a program. (Essentially a ctrl+F for binary files)</p><p><strong>Function Tree</strong> - A graphical representation of cross-references. Allows you to see which function calls a given resource and which function calls that function. And so on. Quite literally, a "tree" of function calls that enables you to visualize paths of execution.</p><p>Using cross-references - I would be able to find out where <code>VirtualAlloc</code> is called within the program.</p><p>Using the Function Tree - This would allow me to view the path taken to get to <code>VirtualAlloc</code> and potentially identify reasons why <code>VirtualAlloc</code> is not being triggered.</p><h2 id="how-to-use-cross-references-in-ghidra">How to use cross-references in Ghidra</h2><p>To locate cross references to VirtualAlloc - I first located <code>VirtualAlloc</code> within the Symbol tree of Ghidra.</p><p><code>Symbol Tree → Imports → Kernel32.DLL → VirtualAlloc</code></p><p>(You could browse through the symbols manually or use the filter to speed things up)</p><figure class="kg-card kg-image-card"><img src="https://embee-research.ghost.io/content/images/2023/04/image-201.png" class="kg-image" alt="https://embee-research.ghost.io/content/images/2023/04/image-201.png" loading="lazy" width="560" height="560"></figure><p>I then accessed cross-references by right-clicking on the VirtualAlloc symbol and selecting.  <code>Show References to</code>.</p><figure class="kg-card kg-image-card"><img src="https://embee-research.ghost.io/content/images/2023/04/image-202.png" class="kg-image" alt="https://embee-research.ghost.io/content/images/2023/04/image-202.png" loading="lazy" width="755" height="688" srcset="https://embee-research.ghost.io/content/images/size/w600/2023/04/image-202.png 600w, https://embee-research.ghost.io/content/images/2023/04/image-202.png 755w" sizes="(min-width: 720px) 720px"></figure><p>This revealed the cross references. With only one function that calls <code>VirtualAlloc</code> - I clicked on this function to view its contents and establish context around the VirtualAlloc call.</p><p>(The context/data reference can be ignored, this is not a function call)</p><figure class="kg-card kg-image-card"><img src="https://embee-research.ghost.io/content/images/2023/04/image-203.png" class="kg-image" alt="https://embee-research.ghost.io/content/images/2023/04/image-203.png" loading="lazy" width="1741" height="535" srcset="https://embee-research.ghost.io/content/images/size/w600/2023/04/image-203.png 600w, https://embee-research.ghost.io/content/images/size/w1000/2023/04/image-203.png 1000w, https://embee-research.ghost.io/content/images/size/w1600/2023/04/image-203.png 1600w, https://embee-research.ghost.io/content/images/2023/04/image-203.png 1741w" sizes="(min-width: 720px) 720px"></figure><p>Here (below), the surrounding code and context are revealed.</p><p>This is the code that executes (39) the <code>VirtualAlloc</code> function. In this screenshot, we can see that the <code>VirtualAlloc</code> function is called (39), then <code>_memcpy</code> is used (47) to copy data into the buffer, then the buffer is xor'd <code>^</code> with a key (49).</p><figure class="kg-card kg-image-card"><img src="https://embee-research.ghost.io/content/images/2023/04/image-205.png" class="kg-image" alt="https://embee-research.ghost.io/content/images/2023/04/image-205.png" loading="lazy" width="1811" height="773" srcset="https://embee-research.ghost.io/content/images/size/w600/2023/04/image-205.png 600w, https://embee-research.ghost.io/content/images/size/w1000/2023/04/image-205.png 1000w, https://embee-research.ghost.io/content/images/size/w1600/2023/04/image-205.png 1600w, https://embee-research.ghost.io/content/images/2023/04/image-205.png 1811w" sizes="(min-width: 720px) 720px"></figure><p>Here is a slightly better view with only the most relevant information visible.</p><p>Line 39 - Call VirtualAlloc to create a memory buffer</p><p>Line 47 - Copy some data into that buffer</p><p>Line 49 - Use XOR <code>^</code> To decode the data in that buffer.</p><p>Line 51 - Execute the buffer as code.</p><figure class="kg-card kg-image-card"><img src="https://embee-research.ghost.io/content/images/2023/04/image-206.png" class="kg-image" alt="https://embee-research.ghost.io/content/images/2023/04/image-206.png" loading="lazy" width="1841" height="859" srcset="https://embee-research.ghost.io/content/images/size/w600/2023/04/image-206.png 600w, https://embee-research.ghost.io/content/images/size/w1000/2023/04/image-206.png 1000w, https://embee-research.ghost.io/content/images/size/w1600/2023/04/image-206.png 1600w, https://embee-research.ghost.io/content/images/2023/04/image-206.png 1841w" sizes="(min-width: 720px) 720px"></figure><p>From this, we can determine that the VirtualAlloc buffer is being used to <strong><em>store and execute some kind of code</em></strong>.</p><p>This is great - but why is the <code>VirtualAlloc</code> function never hit in the first place?</p><p>For this - we need to see what happens before <code>VirtualAlloc</code>.</p><p>Since we have already located the relevant function - we can scroll up to see what happens before <code>VirtualAlloc</code> and determine why it might not be being hit.</p><p>Below we can see the contents before the VirtualAlloc call on Line 39.</p><figure class="kg-card kg-image-card"><img src="https://embee-research.ghost.io/content/images/2023/04/image-207.png" class="kg-image" alt="https://embee-research.ghost.io/content/images/2023/04/image-207.png" loading="lazy" width="1846" height="1301" srcset="https://embee-research.ghost.io/content/images/size/w600/2023/04/image-207.png 600w, https://embee-research.ghost.io/content/images/size/w1000/2023/04/image-207.png 1000w, https://embee-research.ghost.io/content/images/size/w1600/2023/04/image-207.png 1600w, https://embee-research.ghost.io/content/images/2023/04/image-207.png 1846w" sizes="(min-width: 720px) 720px"></figure><p>There's quite a bit happening - so here’s a breakdown. The first is an anti-debug/anti-emulation check using timers.</p><figure class="kg-card kg-image-card"><img src="https://embee-research.ghost.io/content/images/2023/04/image-209.png" class="kg-image" alt="https://embee-research.ghost.io/content/images/2023/04/image-209.png" loading="lazy" width="832" height="283" srcset="https://embee-research.ghost.io/content/images/size/w600/2023/04/image-209.png 600w, https://embee-research.ghost.io/content/images/2023/04/image-209.png 832w" sizes="(min-width: 720px) 720px"></figure><p>Lines 14-19 - This is an anti-debug/emulation check to bypass sandboxes that patch the Sleep function with a value of 0.</p><p>Line 14 - <code>GetTickCount</code> is used to check the number of milliseconds that have elapsed since the system was started.</p><p>Line 15 - The Malware calls <code>Sleep</code> for 0x2be (702) milliseconds.</p><p>Line 16 - <code>GetTickCount</code> is used again to determine how many milliseconds have elapsed since the system was started.</p><p>Line 17 - If less than 700 milliseconds have passed, set a variable to <code>0</code> and <strong><em>don’t continue execution.</em></strong></p><p>Windows Calculator (programmer mode) can convert the 0x2be into decimal to obtain 702 milliseconds.</p><figure class="kg-card kg-image-card"><img src="https://embee-research.ghost.io/content/images/2023/04/image-210.png" class="kg-image" alt="https://embee-research.ghost.io/content/images/2023/04/image-210.png" loading="lazy" width="584" height="226"></figure><p>Although this anti-analysis check was interesting - I had a gut feeling that it wasn't the issue, so I didn’t investigate it further.</p><p>In lines <code>21-24</code> below - we can see the <code>CreateFileA</code> function is called.</p><p>This is used to open a file from disk (the first parameter, stored in param_3).</p><p>I wanted to know which file was being opened and whether the failure to open this file may be what is breaking the malware execution.</p><figure class="kg-card kg-image-card"><img src="https://embee-research.ghost.io/content/images/2023/04/image-211.png" class="kg-image" alt="https://embee-research.ghost.io/content/images/2023/04/image-211.png" loading="lazy" width="1754" height="234" srcset="https://embee-research.ghost.io/content/images/size/w600/2023/04/image-211.png 600w, https://embee-research.ghost.io/content/images/size/w1000/2023/04/image-211.png 1000w, https://embee-research.ghost.io/content/images/size/w1600/2023/04/image-211.png 1600w, https://embee-research.ghost.io/content/images/2023/04/image-211.png 1754w" sizes="(min-width: 720px) 720px"></figure><p>I decided to use a debugger to monitor the first argument to <code>CreateFileA</code></p><p>I did this by creating a breakpoint with <code>bp CreateFileA</code> and allowing the Malware to execute.</p><figure class="kg-card kg-image-card"><img src="https://embee-research.ghost.io/content/images/2023/04/image-212.png" class="kg-image" alt="https://embee-research.ghost.io/content/images/2023/04/image-212.png" loading="lazy" width="2000" height="860" srcset="https://embee-research.ghost.io/content/images/size/w600/2023/04/image-212.png 600w, https://embee-research.ghost.io/content/images/size/w1000/2023/04/image-212.png 1000w, https://embee-research.ghost.io/content/images/size/w1600/2023/04/image-212.png 1600w, https://embee-research.ghost.io/content/images/size/w2400/2023/04/image-212.png 2400w" sizes="(min-width: 720px) 720px"></figure><p>(Above) - the breakpoint is immediately hit.</p><p>(Below) - Confirmation that the first argument <code>lpFileName</code> is the one containing the file name.</p><figure class="kg-card kg-image-card"><img src="https://embee-research.ghost.io/content/images/2023/04/image-214.png" class="kg-image" alt="https://embee-research.ghost.io/content/images/2023/04/image-214.png" loading="lazy" width="1359" height="482" srcset="https://embee-research.ghost.io/content/images/size/w600/2023/04/image-214.png 600w, https://embee-research.ghost.io/content/images/size/w1000/2023/04/image-214.png 1000w, https://embee-research.ghost.io/content/images/2023/04/image-214.png 1359w" sizes="(min-width: 720px) 720px"></figure><p>So I followed the first argument, which can be found on the right side of the debugger window.</p><p>I viewed the contents of the first argument <code>[esp+4]</code> using “Follow in Dump.”</p><figure class="kg-card kg-image-card"><img src="https://embee-research.ghost.io/content/images/2023/04/image-216.png" class="kg-image" alt="https://embee-research.ghost.io/content/images/2023/04/image-216.png" loading="lazy" width="1148" height="365" srcset="https://embee-research.ghost.io/content/images/size/w600/2023/04/image-216.png 600w, https://embee-research.ghost.io/content/images/size/w1000/2023/04/image-216.png 1000w, https://embee-research.ghost.io/content/images/2023/04/image-216.png 1148w" sizes="(min-width: 720px) 720px"></figure><p>(below) In the resulting dump window -  I could see only junk and not a valid file name.</p><figure class="kg-card kg-image-card"><img src="https://embee-research.ghost.io/content/images/2023/04/image-217.png" class="kg-image" alt="https://embee-research.ghost.io/content/images/2023/04/image-217.png" loading="lazy" width="1755" height="373" srcset="https://embee-research.ghost.io/content/images/size/w600/2023/04/image-217.png 600w, https://embee-research.ghost.io/content/images/size/w1000/2023/04/image-217.png 1000w, https://embee-research.ghost.io/content/images/size/w1600/2023/04/image-217.png 1600w, https://embee-research.ghost.io/content/images/2023/04/image-217.png 1755w" sizes="(min-width: 720px) 720px"></figure><p>I then scrolled up slightly. This revealed the command line of the file being executed.</p><p>Notably, the command line is empty after the <code>cwlkewfbz.exe</code>.</p><figure class="kg-card kg-image-card"><img src="https://embee-research.ghost.io/content/images/2023/04/image-218.png" class="kg-image" alt="https://embee-research.ghost.io/content/images/2023/04/image-218.png" loading="lazy" width="1705" height="445" srcset="https://embee-research.ghost.io/content/images/size/w600/2023/04/image-218.png 600w, https://embee-research.ghost.io/content/images/size/w1000/2023/04/image-218.png 1000w, https://embee-research.ghost.io/content/images/size/w1600/2023/04/image-218.png 1600w, https://embee-research.ghost.io/content/images/2023/04/image-218.png 1705w" sizes="(min-width: 720px) 720px"></figure><p>I suspected this was causing issues. So I allowed the function to execute and checked the return value to determine if an error was occurring, which may break the Malware.</p><p>Unsurprisingly - the return value for <code>CreateFileA</code> is <code>0xffffffff</code> (EAX in top right) - which indicates an error.</p><figure class="kg-card kg-image-card"><img src="https://embee-research.ghost.io/content/images/2023/04/image-220.png" class="kg-image" alt="https://embee-research.ghost.io/content/images/2023/04/image-220.png" loading="lazy" width="2000" height="493" srcset="https://embee-research.ghost.io/content/images/size/w600/2023/04/image-220.png 600w, https://embee-research.ghost.io/content/images/size/w1000/2023/04/image-220.png 1000w, https://embee-research.ghost.io/content/images/size/w1600/2023/04/image-220.png 1600w, https://embee-research.ghost.io/content/images/size/w2400/2023/04/image-220.png 2400w" sizes="(min-width: 720px) 720px"></figure><p>The call to <code>CreateFileA</code> is within a long series of <code>if-else</code> statements which ultimately execute the 2nd stage. If any statements fail, the Malware sets <code>Bvar3</code> to 0 and exits.</p><p>Line 22 - Since the result of CreateFileA is an error <code>0xffffffff</code>, the Malware will not continue to the next API of CreateFileMappingA.</p><figure class="kg-card kg-image-card"><img src="https://embee-research.ghost.io/content/images/2023/04/image-221.png" class="kg-image" alt="https://embee-research.ghost.io/content/images/2023/04/image-221.png" loading="lazy" width="1842" height="479" srcset="https://embee-research.ghost.io/content/images/size/w600/2023/04/image-221.png 600w, https://embee-research.ghost.io/content/images/size/w1000/2023/04/image-221.png 1000w, https://embee-research.ghost.io/content/images/size/w1600/2023/04/image-221.png 1600w, https://embee-research.ghost.io/content/images/2023/04/image-221.png 1842w" sizes="(min-width: 720px) 720px"></figure><h2 id="fixing-the-createfilea">Fixing the CreateFileA</h2><p>It was now reasonably safe to assume that the <code>CreateFileA</code> error was causing the Malware to terminate before the call to <code>VirtualAlloc</code>.</p><p>To fix this and continue execution - we needed to know which value was being expected in the call to <code>CreateFileA</code></p><p>Our previous analysis of the <code>.nsi</code> script reveals the file that should be in this command line. <code>pgkayd.aq</code></p><figure class="kg-card kg-image-card"><img src="https://embee-research.ghost.io/content/images/2023/04/image-223.png" class="kg-image" alt="https://embee-research.ghost.io/content/images/2023/04/image-223.png" loading="lazy" width="1327" height="578" srcset="https://embee-research.ghost.io/content/images/size/w600/2023/04/image-223.png 600w, https://embee-research.ghost.io/content/images/size/w1000/2023/04/image-223.png 1000w, https://embee-research.ghost.io/content/images/2023/04/image-223.png 1327w" sizes="(min-width: 720px) 720px"></figure><h2 id="analysisatch-the-command-line-in-x32dbg">Analysisatch the command line in x32dbg.</h2><p>We can use x32dbg to a modify the command line to the correct values that match the <code>.nsi</code> script.</p><p>Within x32dbg you can browse to  <code>File -&gt; Change Command Line</code></p><figure class="kg-card kg-image-card"><img src="https://embee-research.ghost.io/content/images/2023/04/image-226.png" class="kg-image" alt="https://embee-research.ghost.io/content/images/2023/04/image-226.png" loading="lazy" width="481" height="559"></figure><p>And then crudely add the value of <code>pgkayd.aq</code> from the <code>.nsi</code> script. (I found that the full path was not required)</p><figure class="kg-card kg-image-card"><img src="https://embee-research.ghost.io/content/images/2023/04/image-227.png" class="kg-image" alt="https://embee-research.ghost.io/content/images/2023/04/image-227.png" loading="lazy" width="1231" height="114" srcset="https://embee-research.ghost.io/content/images/size/w600/2023/04/image-227.png 600w, https://embee-research.ghost.io/content/images/size/w1000/2023/04/image-227.png 1000w, https://embee-research.ghost.io/content/images/2023/04/image-227.png 1231w" sizes="(min-width: 720px) 720px"></figure><p>The modified command line looked like this.</p><figure class="kg-card kg-image-card"><img src="https://embee-research.ghost.io/content/images/2023/04/image-229.png" class="kg-image" alt="https://embee-research.ghost.io/content/images/2023/04/image-229.png" loading="lazy" width="832" height="199" srcset="https://embee-research.ghost.io/content/images/size/w600/2023/04/image-229.png 600w, https://embee-research.ghost.io/content/images/2023/04/image-229.png 832w" sizes="(min-width: 720px) 720px"></figure><p>After restarting the program, the first argument to  <code>CreateFileA</code> now contains the correct file.</p><figure class="kg-card kg-image-card"><img src="https://embee-research.ghost.io/content/images/2023/04/image-230.png" class="kg-image" alt="https://embee-research.ghost.io/content/images/2023/04/image-230.png" loading="lazy" width="2000" height="738" srcset="https://embee-research.ghost.io/content/images/size/w600/2023/04/image-230.png 600w, https://embee-research.ghost.io/content/images/size/w1000/2023/04/image-230.png 1000w, https://embee-research.ghost.io/content/images/size/w1600/2023/04/image-230.png 1600w, https://embee-research.ghost.io/content/images/size/w2400/2023/04/image-230.png 2400w" sizes="(min-width: 720px) 720px"></figure><p>Continuing execution - the breakpoint on <code>VirtualAlloc</code>  is triggered successfully.</p><figure class="kg-card kg-image-card"><img src="https://embee-research.ghost.io/content/images/2023/04/image-231.png" class="kg-image" alt="https://embee-research.ghost.io/content/images/2023/04/image-231.png" loading="lazy" width="2000" height="596" srcset="https://embee-research.ghost.io/content/images/size/w600/2023/04/image-231.png 600w, https://embee-research.ghost.io/content/images/size/w1000/2023/04/image-231.png 1000w, https://embee-research.ghost.io/content/images/size/w1600/2023/04/image-231.png 1600w, https://embee-research.ghost.io/content/images/size/w2400/2023/04/image-231.png 2400w" sizes="(min-width: 720px) 720px"></figure><p>We now need to monitor the memory being allocated by VirtualAlloc. This can be done using a similar process that I detailed in my Redline/Amadey Post.</p><p>Using this process - we can be alerted if any content is written to the newly created buffer.</p><ul><li>Set a breakpoint on <code>VirtualAlloc</code></li><li>Use <code>Execute Until Return</code> to obtain the return value (containing the address of the memory buffer)</li><li>Set a hardware breakpoint on the buffer - This will trigger an alert when the buffer is accessed.</li><li>Monitor the "alerts" until the buffer contains something of interest.</li></ul><h2 id="creating-a-hardware-breakpoint-to-decode-malware">Creating a Hardware Breakpoint To Decode Malware</h2><p>To create the Hardware breakpoint from VirtualAlloc - we can hit  <code>CTRL+F9</code> (Execute Until Return) and then <code>Follow in Dump</code> on the return value in EAX.</p><figure class="kg-card kg-image-card"><img src="https://embee-research.ghost.io/content/images/2023/04/image-233.png" class="kg-image" alt="https://embee-research.ghost.io/content/images/2023/04/image-233.png" loading="lazy" width="2000" height="609" srcset="https://embee-research.ghost.io/content/images/size/w600/2023/04/image-233.png 600w, https://embee-research.ghost.io/content/images/size/w1000/2023/04/image-233.png 1000w, https://embee-research.ghost.io/content/images/size/w1600/2023/04/image-233.png 1600w, https://embee-research.ghost.io/content/images/size/w2400/2023/04/image-233.png 2400w" sizes="(min-width: 720px) 720px"></figure><p>With the resulting memory contents in the dump window - we can select the first bytes and create a hardware breakpoint.</p><p>Dump → Right Click → Breakpoint → Hardware Access → Byte</p><p>Then continue execution</p><figure class="kg-card kg-image-card"><img src="https://embee-research.ghost.io/content/images/2023/04/image-232.png" class="kg-image" alt="https://embee-research.ghost.io/content/images/2023/04/image-232.png" loading="lazy" width="1117" height="1182" srcset="https://embee-research.ghost.io/content/images/size/w600/2023/04/image-232.png 600w, https://embee-research.ghost.io/content/images/size/w1000/2023/04/image-232.png 1000w, https://embee-research.ghost.io/content/images/2023/04/image-232.png 1117w" sizes="(min-width: 720px) 720px"></figure><p>Once the hardware breakpoint has been set - We can allow the Malware to continue to execute.</p><p>Soon - the hardware breakpoint is triggered and a single byte <code>DB</code> is written into the buffer. We can hit <code>CTRL+F9</code> to continue execution and allow the buffer to finish filling up.</p><figure class="kg-card kg-image-card"><img src="https://embee-research.ghost.io/content/images/2023/04/image-234.png" class="kg-image" alt="https://embee-research.ghost.io/content/images/2023/04/image-234.png" loading="lazy" width="1710" height="769" srcset="https://embee-research.ghost.io/content/images/size/w600/2023/04/image-234.png 600w, https://embee-research.ghost.io/content/images/size/w1000/2023/04/image-234.png 1000w, https://embee-research.ghost.io/content/images/size/w1600/2023/04/image-234.png 1600w, https://embee-research.ghost.io/content/images/2023/04/image-234.png 1710w" sizes="(min-width: 720px) 720px"></figure><p>The buffer quickly fills up - but does not contain a <code>MZ</code> header (indicating an unpacked file). There are also no visible strings within the dumped content.</p><figure class="kg-card kg-image-card"><img src="https://embee-research.ghost.io/content/images/2023/04/image-235.png" class="kg-image" alt="https://embee-research.ghost.io/content/images/2023/04/image-235.png" loading="lazy" width="1746" height="642" srcset="https://embee-research.ghost.io/content/images/size/w600/2023/04/image-235.png 600w, https://embee-research.ghost.io/content/images/size/w1000/2023/04/image-235.png 1000w, https://embee-research.ghost.io/content/images/size/w1600/2023/04/image-235.png 1600w, https://embee-research.ghost.io/content/images/2023/04/image-235.png 1746w" sizes="(min-width: 720px) 720px"></figure><p>In situations like this - I generally suspect one of two things</p><ul><li>The “junk” is raw machine code (also referred to as shellcode), which often looks like junk.</li><li>The “junk” is not fully decoded yet - in which case we can continue to execute and trigger hardware breakpoints until something of value appears.</li></ul><p>The second option is useful - because the buffer needs to be accessed each time the buffer undergoes a round of decoding - a process that will trigger a hardware breakpoint.</p><h2 id="validating-potential-shellcode"><strong>Validating Potential Shellcode</strong></h2><p>The x32dbg Disassembler can be used to validate whether or not the bytes are shellcode.</p><p>This can be done by selecting the dump data and selecting  <code>Follow in Disassembler</code></p><p>We can see this in action below - note how the first disassembler bytes are <code>DB A3</code> , which aligns with the contents of the dump window.</p><figure class="kg-card kg-image-card"><img src="https://embee-research.ghost.io/content/images/2023/04/image-236.png" class="kg-image" alt="https://embee-research.ghost.io/content/images/2023/04/image-236.png" loading="lazy" width="1742" height="1172" srcset="https://embee-research.ghost.io/content/images/size/w600/2023/04/image-236.png 600w, https://embee-research.ghost.io/content/images/size/w1000/2023/04/image-236.png 1000w, https://embee-research.ghost.io/content/images/size/w1600/2023/04/image-236.png 1600w, https://embee-research.ghost.io/content/images/2023/04/image-236.png 1742w" sizes="(min-width: 720px) 720px"></figure><p>In this case - the disassembled content did not look like valid shellcode. (You can usually tell this by the presence of big red <code>???</code>)</p><p>I decided to continue execution.</p><h3 id="continuing-analysislocating-shellcode">Continuing Analysis - Locating Shellcode</h3><p>Since the initial bytes did not appear to be shellcode or anything of value - I decided to continue execution.</p><p>This triggered another hardware breakpoint on the same bytes and location as before.</p><p>In the below screenshot - we can see <code>EIP</code> that an <code>xor</code> instruction triggered the breakpoint. This is a strong suggestion that decoding is taking place.</p><figure class="kg-card kg-image-card"><img src="https://embee-research.ghost.io/content/images/2023/04/image-237.png" class="kg-image" alt="https://embee-research.ghost.io/content/images/2023/04/image-237.png" loading="lazy" width="1734" height="1306" srcset="https://embee-research.ghost.io/content/images/size/w600/2023/04/image-237.png 600w, https://embee-research.ghost.io/content/images/size/w1000/2023/04/image-237.png 1000w, https://embee-research.ghost.io/content/images/size/w1600/2023/04/image-237.png 1600w, https://embee-research.ghost.io/content/images/2023/04/image-237.png 1734w" sizes="(min-width: 720px) 720px"></figure><p>I then found that continuing execution did not have the intended result that I wanted. The data was decoded as expected, but a hardware breakpoint was not triggered when the first byte was executed.</p><p>Hence - the resulting shellcode was able to execute without triggering a breakpoint.</p><p>To solve this - I went back to Ghidra and checked where the buffer was being executed.</p><figure class="kg-card kg-image-card"><img src="https://embee-research.ghost.io/content/images/2023/04/image-241.png" class="kg-image" alt="https://embee-research.ghost.io/content/images/2023/04/image-241.png" loading="lazy" width="2000" height="841" srcset="https://embee-research.ghost.io/content/images/size/w600/2023/04/image-241.png 600w, https://embee-research.ghost.io/content/images/size/w1000/2023/04/image-241.png 1000w, https://embee-research.ghost.io/content/images/size/w1600/2023/04/image-241.png 1600w, https://embee-research.ghost.io/content/images/size/w2400/2023/04/image-241.png 2400w" sizes="(min-width: 720px) 720px"></figure><p>I then manually set a breakpoint on this address (the one containing the CALL)  so that I could obtain the buffer <strong><em>just prior to it being executed.</em></strong></p><p>This was only a few instructions after the second hardware breakpoint was triggered.</p><p>(TLDR: once you hit the second hardware breakpoint, the CALL address will already be in your disassembly window, about 6 lines after EIP)</p><figure class="kg-card kg-image-card"><img src="https://embee-research.ghost.io/content/images/2023/04/image-243.png" class="kg-image" alt="https://embee-research.ghost.io/content/images/2023/04/image-243.png" loading="lazy" width="1739" height="590" srcset="https://embee-research.ghost.io/content/images/size/w600/2023/04/image-243.png 600w, https://embee-research.ghost.io/content/images/size/w1000/2023/04/image-243.png 1000w, https://embee-research.ghost.io/content/images/size/w1600/2023/04/image-243.png 1600w, https://embee-research.ghost.io/content/images/2023/04/image-243.png 1739w" sizes="(min-width: 720px) 720px"></figure><p>Allowing the Malware to continue to execute until the CALL. We can see a new buffer in the dump window <code>E9 97 0f 00</code></p><figure class="kg-card kg-image-card"><img src="https://embee-research.ghost.io/content/images/2023/04/image-245.png" class="kg-image" alt="https://embee-research.ghost.io/content/images/2023/04/image-245.png" loading="lazy" width="1760" height="1283" srcset="https://embee-research.ghost.io/content/images/size/w600/2023/04/image-245.png 600w, https://embee-research.ghost.io/content/images/size/w1000/2023/04/image-245.png 1000w, https://embee-research.ghost.io/content/images/size/w1600/2023/04/image-245.png 1600w, https://embee-research.ghost.io/content/images/2023/04/image-245.png 1760w" sizes="(min-width: 720px) 720px"></figure><p>We can validate that this is shellcode by using <code>Follow in Disassembler</code>to view the contents as disassembled code.</p><p>This time there are no glaring red <code>???</code> or other shenanigans.</p><figure class="kg-card kg-image-card"><img src="https://embee-research.ghost.io/content/images/2023/04/image-246.png" class="kg-image" alt="https://embee-research.ghost.io/content/images/2023/04/image-246.png" loading="lazy" width="1750" height="1204" srcset="https://embee-research.ghost.io/content/images/size/w600/2023/04/image-246.png 600w, https://embee-research.ghost.io/content/images/size/w1000/2023/04/image-246.png 1000w, https://embee-research.ghost.io/content/images/size/w1600/2023/04/image-246.png 1600w, https://embee-research.ghost.io/content/images/2023/04/image-246.png 1750w" sizes="(min-width: 720px) 720px"></figure><p><strong><em>At this point, you could allow the shellcode to execute. However, we will be analyzing the shellcode manually.</em></strong></p><blockquote>Continuing execution at this point will trigger breakpoints on api’s that are shared between the shellcode  and initial <code>cwlkewfbz.exe</code>  which is still loaded into x32dbg. If you continue execution this way - you can generally continue to debug the shellcode as if it were a regular process. The drawback is that you will not trigger breakpoints on any new api’s imported and/or executed by the shellcode.</blockquote><blockquote>This section was admittedly confusing. If you have gotten lost at any point, restart the process and set a Hardware Breakpoint (Execute) on the return value from VirtualAlloc. This will take you straight to the current point of analysis.</blockquote><h2 id="how-to-save-shellcode-using-x32dbg">How to Save Shellcode Using X32dbg</h2><p>Since this is an education-focused post - I will instead be dumping the shellcode and analyzing it manually.</p><p>You can do the same by reaching the point where the shellcode is executed.</p><p>Then selecting <code>Follow in Memory Map</code> and <code>Dump Memory to File</code></p><figure class="kg-card kg-image-card"><img src="https://embee-research.ghost.io/content/images/2023/04/image-249.png" class="kg-image" alt="https://embee-research.ghost.io/content/images/2023/04/image-249.png" loading="lazy" width="2000" height="1138" srcset="https://embee-research.ghost.io/content/images/size/w600/2023/04/image-249.png 600w, https://embee-research.ghost.io/content/images/size/w1000/2023/04/image-249.png 1000w, https://embee-research.ghost.io/content/images/size/w1600/2023/04/image-249.png 1600w, https://embee-research.ghost.io/content/images/2023/04/image-249.png 2192w" sizes="(min-width: 720px) 720px"></figure><p>I then saved the content as <code>shellcode.bin</code></p><h2 id="how-to-manually-analyse-the-shellcode">How to Manually Analyse the Shellcode</h2><p>At this point I loaded the <code>shellcode.bin</code> file into Ghidra for further analysis.</p><p>Since this is shellcode - The architecture will need to be manually speAnalysiso that Ghidra can load it successfully.</p><p>For the majority of Windows shellcode you will encounter. You can simply enter <code>x86</code> into the filter. Then select a size based on the architecture of process which initially loaded the shellcode.</p><figure class="kg-card kg-image-card"><img src="https://embee-research.ghost.io/content/images/2023/04/image-253.png" class="kg-image" alt="https://embee-research.ghost.io/content/images/2023/04/image-253.png" loading="lazy" width="2000" height="767" srcset="https://embee-research.ghost.io/content/images/size/w600/2023/04/image-253.png 600w, https://embee-research.ghost.io/content/images/size/w1000/2023/04/image-253.png 1000w, https://embee-research.ghost.io/content/images/size/w1600/2023/04/image-253.png 1600w, https://embee-research.ghost.io/content/images/2023/04/image-253.png 2275w" sizes="(min-width: 720px) 720px"></figure><p>In this case - the initial file <code>cwlkewfbz.exe</code>is LE (little endian) and 32-bit. This information can be obtained using detect-it-easy.</p><figure class="kg-card kg-image-card"><img src="https://embee-research.ghost.io/content/images/2023/04/image-254.png" class="kg-image" alt="https://embee-research.ghost.io/content/images/2023/04/image-254.png" loading="lazy" width="1449" height="915" srcset="https://embee-research.ghost.io/content/images/size/w600/2023/04/image-254.png 600w, https://embee-research.ghost.io/content/images/size/w1000/2023/04/image-254.png 1000w, https://embee-research.ghost.io/content/images/2023/04/image-254.png 1449w" sizes="(min-width: 720px) 720px"></figure><p>Any option that is both <code>little</code> and <code>32-bit</code> will be suitable.</p><p>I have generally found that the <code>Compiler</code> column makes no difference for shellcode. Only the <code>Endian</code> , <code>Size</code> and <code>Processor</code> columns matter.</p><figure class="kg-card kg-image-card"><img src="https://embee-research.ghost.io/content/images/2023/04/image-255.png" class="kg-image" alt="https://embee-research.ghost.io/content/images/2023/04/image-255.png" loading="lazy" width="951" height="695" srcset="https://embee-research.ghost.io/content/images/size/w600/2023/04/image-255.png 600w, https://embee-research.ghost.io/content/images/2023/04/image-255.png 951w" sizes="(min-width: 720px) 720px"></figure><p>Once the options have been selected - you can click ok and continue (OK) with the file analysis.</p><figure class="kg-card kg-image-card"><img src="https://embee-research.ghost.io/content/images/2023/04/image-256.png" class="kg-image" alt="https://embee-research.ghost.io/content/images/2023/04/image-256.png" loading="lazy" width="1006" height="526" srcset="https://embee-research.ghost.io/content/images/size/w600/2023/04/image-256.png 600w, https://embee-research.ghost.io/content/images/size/w1000/2023/04/image-256.png 1000w, https://embee-research.ghost.io/content/images/2023/04/image-256.png 1006w" sizes="(min-width: 720px) 720px"></figure><p>Once completed - Ghidra will proceed to decompile the code and it should look like this. Note how there are functions and annotations in both the decompiler and disassembler windows.</p><figure class="kg-card kg-image-card"><img src="https://embee-research.ghost.io/content/images/2023/04/image-260.png" class="kg-image" alt="https://embee-research.ghost.io/content/images/2023/04/image-260.png" loading="lazy" width="2000" height="849" srcset="https://embee-research.ghost.io/content/images/size/w600/2023/04/image-260.png 600w, https://embee-research.ghost.io/content/images/size/w1000/2023/04/image-260.png 1000w, https://embee-research.ghost.io/content/images/size/w1600/2023/04/image-260.png 1600w, https://embee-research.ghost.io/content/images/size/w2400/2023/04/image-260.png 2400w" sizes="(min-width: 720px) 720px"></figure><h2 id="how-to-force-disassembly-of-shellcode-with-ghidra"><strong>How to Force Disassembly of Shellcode With Ghidra</strong></h2><p>If there are no functions or annotations present in your shellcode, Ghidra failed to recognize the start of the code.</p><p>You can easily correct this by selecting the first byte, <code>right-click</code> and <code>Disassemble</code>.</p><p>If anything still looks funny or the decompiler window remains empty - <code>Right-Click</code> again and select <code>Create Function</code></p><figure class="kg-card kg-image-card"><img src="https://embee-research.ghost.io/content/images/2023/04/image-258.png" class="kg-image" alt="https://embee-research.ghost.io/content/images/2023/04/image-258.png" loading="lazy" width="2000" height="900" srcset="https://embee-research.ghost.io/content/images/size/w600/2023/04/image-258.png 600w, https://embee-research.ghost.io/content/images/size/w1000/2023/04/image-258.png 1000w, https://embee-research.ghost.io/content/images/size/w1600/2023/04/image-258.png 1600w, https://embee-research.ghost.io/content/images/size/w2400/2023/04/image-258.png 2400w" sizes="(min-width: 720px) 720px"></figure><figure class="kg-card kg-image-card"><img src="https://embee-research.ghost.io/content/images/2023/04/image-261.png" class="kg-image" alt="https://embee-research.ghost.io/content/images/2023/04/image-261.png" loading="lazy" width="2000" height="765" srcset="https://embee-research.ghost.io/content/images/size/w600/2023/04/image-261.png 600w, https://embee-research.ghost.io/content/images/size/w1000/2023/04/image-261.png 1000w, https://embee-research.ghost.io/content/images/size/w1600/2023/04/image-261.png 1600w, https://embee-research.ghost.io/content/images/2023/04/image-261.png 2000w" sizes="(min-width: 720px) 720px"></figure><p>The decompiler view should go from left to right in the below screenshot.</p><figure class="kg-card kg-image-card"><img src="https://embee-research.ghost.io/content/images/2023/04/image-262.png" class="kg-image" alt="https://embee-research.ghost.io/content/images/2023/04/image-262.png" loading="lazy" width="2000" height="559" srcset="https://embee-research.ghost.io/content/images/size/w600/2023/04/image-262.png 600w, https://embee-research.ghost.io/content/images/size/w1000/2023/04/image-262.png 1000w, https://embee-research.ghost.io/content/images/size/w1600/2023/04/image-262.png 1600w, https://embee-research.ghost.io/content/images/2023/04/image-262.png 2024w" sizes="(min-width: 720px) 720px"></figure><p>Once this is setup - You can click the one and only available function.</p><figure class="kg-card kg-image-card"><img src="https://embee-research.ghost.io/content/images/2023/04/image-263.png" class="kg-image" alt="https://embee-research.ghost.io/content/images/2023/04/image-263.png" loading="lazy" width="1013" height="404" srcset="https://embee-research.ghost.io/content/images/size/w600/2023/04/image-263.png 600w, https://embee-research.ghost.io/content/images/size/w1000/2023/04/image-263.png 1000w, https://embee-research.ghost.io/content/images/2023/04/image-263.png 1013w" sizes="(min-width: 720px) 720px"></figure><h2 id="analysis-of-the-shellcode-using-ghidra">Analysis of The Shellcode Using Ghidra</h2><p>This reveals a function <code>FUN_00000f9c</code> that begins by initialising a bunch of stack variables which can largely be ignored for now.</p><figure class="kg-card kg-image-card"><img src="https://embee-research.ghost.io/content/images/2023/04/image-264.png" class="kg-image" alt="https://embee-research.ghost.io/content/images/2023/04/image-264.png" loading="lazy" width="1717" height="771" srcset="https://embee-research.ghost.io/content/images/size/w600/2023/04/image-264.png 600w, https://embee-research.ghost.io/content/images/size/w1000/2023/04/image-264.png 1000w, https://embee-research.ghost.io/content/images/size/w1600/2023/04/image-264.png 1600w, https://embee-research.ghost.io/content/images/2023/04/image-264.png 1717w" sizes="(min-width: 720px) 720px"></figure><p>Scrolling down further, we can see some potential stack strings.</p><h3 id="identifying-stack-strings-in-ghidra">Identifying Stack Strings in Ghidra</h3><p>You can generally suspect stack strings when you see lots of hex or decimal values being set on stack variables.</p><p>Since nullbytes are used to terminate each string - this is also a dead giveaway.</p><figure class="kg-card kg-image-card"><img src="https://embee-research.ghost.io/content/images/2023/04/image-265.png" class="kg-image" alt="https://embee-research.ghost.io/content/images/2023/04/image-265.png" loading="lazy" width="1724" height="683" srcset="https://embee-research.ghost.io/content/images/size/w600/2023/04/image-265.png 600w, https://embee-research.ghost.io/content/images/size/w1000/2023/04/image-265.png 1000w, https://embee-research.ghost.io/content/images/size/w1600/2023/04/image-265.png 1600w, https://embee-research.ghost.io/content/images/2023/04/image-265.png 1724w" sizes="(min-width: 720px) 720px"></figure><p>These stack strings can be decoded in Ghidra by right-clicking on each value and selecting char.</p><figure class="kg-card kg-image-card"><img src="https://embee-research.ghost.io/content/images/2023/04/image-270.png" class="kg-image" alt="https://embee-research.ghost.io/content/images/2023/04/image-270.png" loading="lazy" width="2000" height="580" srcset="https://embee-research.ghost.io/content/images/size/w600/2023/04/image-270.png 600w, https://embee-research.ghost.io/content/images/size/w1000/2023/04/image-270.png 1000w, https://embee-research.ghost.io/content/images/size/w1600/2023/04/image-270.png 1600w, https://embee-research.ghost.io/content/images/2023/04/image-270.png 2043w" sizes="(min-width: 720px) 720px"></figure><p>Once the first stack string is decoded, we can see a value of <code>djdqvq.sra</code>. Which is the remaining file in our unzipped nullsoft folder.</p><p>After this value - are a few more stack strings which I presume to be folder and file names for later use.</p><figure class="kg-card kg-image-card"><img src="https://embee-research.ghost.io/content/images/2023/04/image-271.png" class="kg-image" alt="https://embee-research.ghost.io/content/images/2023/04/image-271.png" loading="lazy" width="2000" height="583" srcset="https://embee-research.ghost.io/content/images/size/w600/2023/04/image-271.png 600w, https://embee-research.ghost.io/content/images/size/w1000/2023/04/image-271.png 1000w, https://embee-research.ghost.io/content/images/size/w1600/2023/04/image-271.png 1600w, https://embee-research.ghost.io/content/images/2023/04/image-271.png 2181w" sizes="(min-width: 720px) 720px"></figure><h3 id="identifying-api-hashing-in-shellcode"><strong>Identifying API Hashing in Shellcode</strong></h3><p>Immediately following the stack strings - there is a suspicious function <code>FUN_00000073</code>that is called repeatedly. Each call to <code>FUN_00000073</code> contains the same first argument, as well as a second argument containing hash-like value.</p><p>On lines <code>111</code> and <code>113</code> - We can see that a returned result is executed as code. This is an extremely strong indicator that <code>FUN_00000073</code> is an API hashing function.</p><figure class="kg-card kg-image-card"><img src="https://embee-research.ghost.io/content/images/2023/04/image-272.png" class="kg-image" alt="https://embee-research.ghost.io/content/images/2023/04/image-272.png" loading="lazy" width="1306" height="477" srcset="https://embee-research.ghost.io/content/images/size/w600/2023/04/image-272.png 600w, https://embee-research.ghost.io/content/images/size/w1000/2023/04/image-272.png 1000w, https://embee-research.ghost.io/content/images/2023/04/image-272.png 1306w" sizes="(min-width: 720px) 720px"></figure><p>Based on the above analysis - we have enough information to determine that the function performs api Analysisand resolution. You could always manually inspect the function to determine the exact hashing type, but this is a manual process for a future blog post.</p><p>Instead - I will focus on a repeatable method to resolve unknown api hashes using a debugger. This method should work regardless of the api hashing method used and does not rely on 3rd party scripts or an internet connection.</p><h2 id="how-to-defeat-api-hashes-with-a-debugger">How to Defeat <strong>API Hashes With A Debugger</strong></h2><p>A debugger (x32dbg/x64dbg) can be used to monitor the input and output of the api-hashing function and easily obtain the decoded api’s and their corresponding hashes. This is primarily achieved using the logging feature of x64dbg.</p><p>To Do This</p><ul><li>Load shellcode into a debugger using blobrunner</li><li>Set Breakpoints on the api hashing function <code>FUN_00000073</code></li><li>One breakpoint for the beginning (containing the hashed api name)</li><li>One breakpoint for the end (containing the resolved api)</li><li>Once working - convert the breakpoints into conditional breakpoints that log the interesting values.</li><li>View the log window for hashes as well as decoded api’s</li></ul><h3 id="how-to-load-shellcode-into-a-debugger-x32dbg"><strong>How to Load Shellcode Into a Debugger (x32dbg)</strong></h3><p>Since shellcode can not be loaded directly into a debugger - I will use Blobrunner from OALabs.</p><blockquote>The purpose of Blobrunner is to load the shellcode and provide a process that can be attached to using a debugger.</blockquote><p>To do this - you can download blobrunner from github, copy it to the same directory as your shellcode, then open a command line and run <code>blobrunner.exe shellcode.bin</code></p><p>(Make sure to place the blobrunner files in the same folder as your shellcode, and use the 32-bit version <code>blobrunner.exe</code> and not <code>blobrunner64.exe</code>)</p><figure class="kg-card kg-image-card"><img src="https://embee-research.ghost.io/content/images/2023/04/image-277.png" class="kg-image" alt="https://embee-research.ghost.io/content/images/2023/04/image-277.png" loading="lazy" width="1468" height="342" srcset="https://embee-research.ghost.io/content/images/size/w600/2023/04/image-277.png 600w, https://embee-research.ghost.io/content/images/size/w1000/2023/04/image-277.png 1000w, https://embee-research.ghost.io/content/images/2023/04/image-277.png 1468w" sizes="(min-width: 720px) 720px"></figure><figure class="kg-card kg-image-card"><img src="https://embee-research.ghost.io/content/images/2023/04/image-276.png" class="kg-image" alt="https://embee-research.ghost.io/content/images/2023/04/image-276.png" loading="lazy" width="597" height="127"></figure><p>Successful execution will show a small window containing a base address <code>0x00860000</code> where the shellcode has been loaded into.</p><p>Note that the base address will be different for each execution.</p><figure class="kg-card kg-image-card"><img src="https://embee-research.ghost.io/content/images/2023/04/image-278.png" class="kg-image" alt="https://embee-research.ghost.io/content/images/2023/04/image-278.png" loading="lazy" width="1584" height="666" srcset="https://embee-research.ghost.io/content/images/size/w600/2023/04/image-278.png 600w, https://embee-research.ghost.io/content/images/size/w1000/2023/04/image-278.png 1000w, https://embee-research.ghost.io/content/images/2023/04/image-278.png 1584w" sizes="(min-width: 720px) 720px"></figure><p>Once the base address <code>0x00860000</code> of the shellcode has been obtained- you can open x32dbg and attach to Blobrunner</p><h3 id="attaching-to-blobrunner-using-x32dbg"><strong>Attaching to Blobrunner using X32dbg</strong></h3><p>X32dbg can be used to attach to the blobrunner process containing shellcode.</p><p><code>File -&gt; Attach -&gt; Blobrunner.exe</code></p><p>Once attached - a breakpoint should be created on the base address containing the shellcode.</p><p>In this case - the address was <code>0x00860000</code></p><p>The command <code>bp 0x00860000</code> will create the breakpoint.</p><p>At this point - you can press any button in the Blobrunner command window and the shellcode breakpoint should be triggered.</p><figure class="kg-card kg-image-card"><img src="https://embee-research.ghost.io/content/images/2023/04/image-281.png" class="kg-image" alt="https://embee-research.ghost.io/content/images/2023/04/image-281.png" loading="lazy" width="538" height="91"></figure><figure class="kg-card kg-image-card"><img src="https://embee-research.ghost.io/content/images/2023/04/image-280.png" class="kg-image" alt="https://embee-research.ghost.io/content/images/2023/04/image-280.png" loading="lazy" width="2000" height="1012" srcset="https://embee-research.ghost.io/content/images/size/w600/2023/04/image-280.png 600w, https://embee-research.ghost.io/content/images/size/w1000/2023/04/image-280.png 1000w, https://embee-research.ghost.io/content/images/size/w1600/2023/04/image-280.png 1600w, https://embee-research.ghost.io/content/images/size/w2400/2023/04/image-280.png 2400w" sizes="(min-width: 720px) 720px"></figure><h2 id="setting-a-breakpoint-on-the-api-hashing-function"><strong>Setting a Breakpoint on the API Hashing Function</strong></h2><p>At this point - A breakpoint should be set on the API hashing function <code>FUN_00000073</code></p><p>To set the breakpoint - we can either</p><ul><li>Sync the addresses between x32dbg and Ghidra (see my previous blog).</li><li>Set a breakpoint on the base address + 0x73.</li></ul><p>The easiest way to is set a breakpoint on the base address <code>0x00860000</code> + <code>0x73</code></p><figure class="kg-card kg-image-card"><img src="https://embee-research.ghost.io/content/images/2023/04/image-282.png" class="kg-image" alt="https://embee-research.ghost.io/content/images/2023/04/image-282.png" loading="lazy" width="521" height="121"></figure><p>Allowing the shellcode to execute the program - the breakpoint on the api hashing function <code>0x00860073</code> is triggered.</p><figure class="kg-card kg-image-card"><img src="https://embee-research.ghost.io/content/images/2023/04/image-283.png" class="kg-image" alt="https://embee-research.ghost.io/content/images/2023/04/image-283.png" loading="lazy" width="1648" height="525" srcset="https://embee-research.ghost.io/content/images/size/w600/2023/04/image-283.png 600w, https://embee-research.ghost.io/content/images/size/w1000/2023/04/image-283.png 1000w, https://embee-research.ghost.io/content/images/size/w1600/2023/04/image-283.png 1600w, https://embee-research.ghost.io/content/images/2023/04/image-283.png 1648w" sizes="(min-width: 720px) 720px"></figure><p>At the point where the breakpoint is triggered, we can see the first api hash of <code>0x7f91a078</code> contained in the second argument to <code>0x00860073</code></p><blockquote>(Note that x32dbg assumes 5 arguments by default, we can ignore args 3,4 and 5 as we know the function only takes two)</blockquote><figure class="kg-card kg-image-card"><img src="https://embee-research.ghost.io/content/images/2023/04/image-284.png" class="kg-image" alt="https://embee-research.ghost.io/content/images/2023/04/image-284.png" loading="lazy" width="1238" height="259" srcset="https://embee-research.ghost.io/content/images/size/w600/2023/04/image-284.png 600w, https://embee-research.ghost.io/content/images/size/w1000/2023/04/image-284.png 1000w, https://embee-research.ghost.io/content/images/2023/04/image-284.png 1238w" sizes="(min-width: 720px) 720px"></figure><p>This first hash of <code>0x7f91a078</code> corresponds to the first call at <code>0x00000f45</code></p><figure class="kg-card kg-image-card"><img src="https://embee-research.ghost.io/content/images/2023/04/image-285.png" class="kg-image" alt="https://embee-research.ghost.io/content/images/2023/04/image-285.png" loading="lazy" width="1962" height="287" srcset="https://embee-research.ghost.io/content/images/size/w600/2023/04/image-285.png 600w, https://embee-research.ghost.io/content/images/size/w1000/2023/04/image-285.png 1000w, https://embee-research.ghost.io/content/images/size/w1600/2023/04/image-285.png 1600w, https://embee-research.ghost.io/content/images/2023/04/image-285.png 1962w" sizes="(min-width: 720px) 720px"></figure><p>To obtain the decoded api name - <code>Execute Until Return</code> and monitor the return value in <code>EAX</code>.</p><p>This reveals that the first hash of <code>0x7f91a078</code> corresponds to <code>Kernel32.ExitProcess</code>.</p><figure class="kg-card kg-image-card"><img src="https://embee-research.ghost.io/content/images/2023/04/image-286.png" class="kg-image" alt="https://embee-research.ghost.io/content/images/2023/04/image-286.png" loading="lazy" width="1240" height="253" srcset="https://embee-research.ghost.io/content/images/size/w600/2023/04/image-286.png 600w, https://embee-research.ghost.io/content/images/size/w1000/2023/04/image-286.png 1000w, https://embee-research.ghost.io/content/images/2023/04/image-286.png 1240w" sizes="(min-width: 720px) 720px"></figure><p>Allowing the Malware to continue to execute - the api hashing function is triggered again. This time with a hash of <code>0x7fae6c34</code>.</p><figure class="kg-card kg-image-card"><img src="https://embee-research.ghost.io/content/images/2023/04/image-287.png" class="kg-image" alt="https://embee-research.ghost.io/content/images/2023/04/image-287.png" loading="lazy" width="1242" height="250" srcset="https://embee-research.ghost.io/content/images/size/w600/2023/04/image-287.png 600w, https://embee-research.ghost.io/content/images/size/w1000/2023/04/image-287.png 1000w, https://embee-research.ghost.io/content/images/2023/04/image-287.png 1242w" sizes="(min-width: 720px) 720px"></figure><p>Executing until return - we see that <code>0x7fae6c34</code> resolves to <code>kernel32.VirtualAllocExNuma</code>.</p><p>It is now worth noting that the decoded API hash resides in the return value <code>EAX</code> whenever <code>EIP</code> is at the end of the api hashing function  <code>0x008600c9</code>.</p><ul><li>if EIP == 0x008600c9 → then EAX == Decoded API name</li></ul><figure class="kg-card kg-image-card"><img src="https://embee-research.ghost.io/content/images/2023/04/image-291.png" class="kg-image" alt="https://embee-research.ghost.io/content/images/2023/04/image-291.png" loading="lazy" width="2000" height="535" srcset="https://embee-research.ghost.io/content/images/size/w600/2023/04/image-291.png 600w, https://embee-research.ghost.io/content/images/size/w1000/2023/04/image-291.png 1000w, https://embee-research.ghost.io/content/images/size/w1600/2023/04/image-291.png 1600w, https://embee-research.ghost.io/content/images/2023/04/image-291.png 2003w" sizes="(min-width: 720px) 720px"></figure><p>At this point - A Ghidra database could be modified with the first two resolved api names.</p><figure class="kg-card kg-image-card"><img src="https://embee-research.ghost.io/content/images/2023/04/image-289.png" class="kg-image" alt="https://embee-research.ghost.io/content/images/2023/04/image-289.png" loading="lazy" width="1000" height="154" srcset="https://embee-research.ghost.io/content/images/size/w600/2023/04/image-289.png 600w, https://embee-research.ghost.io/content/images/2023/04/image-289.png 1000w" sizes="(min-width: 720px) 720px"></figure><p>For example - by converting Line 18 (above) the above to this (below)</p><figure class="kg-card kg-image-card"><img src="https://embee-research.ghost.io/content/images/2023/04/image-290.png" class="kg-image" alt="https://embee-research.ghost.io/content/images/2023/04/image-290.png" loading="lazy" width="1169" height="149" srcset="https://embee-research.ghost.io/content/images/size/w600/2023/04/image-290.png 600w, https://embee-research.ghost.io/content/images/size/w1000/2023/04/image-290.png 1000w, https://embee-research.ghost.io/content/images/2023/04/image-290.png 1169w" sizes="(min-width: 720px) 720px"></figure><p>Marking up Ghidra is not a complicated process - but it is somewhat tedious and hence will be left as an exercise.</p><h2 id="how-to-automate-api-hashing-with-a-debugger-x32dbg">How to Automate API Hashing with A Debugger (x32dbg)</h2><p>At this point we now know a few key pieces of information</p><ul><li>The exact location where the api resolving function starts <code>&lt;base&gt; + 0x73</code></li><li>The exact location containing the hashed api name (2nd arg, <code>[esp+8]</code>)</li><li>The exact location where the decoded api name can be found <code>&lt;base&gt; + 0xc9</code></li></ul><p>We can now simply create breakpoints with log conditions to obtain the hashes and decoded values.</p><p>This will require two primary conditional breakpoints.</p><ol><li>On the API hashing function <code>&lt;base&gt; + 0x73</code> - This is to log the hash</li><li>On the End of the API hashing function <code>&lt;base&gt; + 0xc9</code> - To log the decoded value</li></ol><p>This can be achieved by restarting blobrunner (Making sure to set breakpoints according to the new base address)</p><figure class="kg-card kg-image-card"><img src="https://embee-research.ghost.io/content/images/2023/04/image-293.png" class="kg-image" alt="https://embee-research.ghost.io/content/images/2023/04/image-293.png" loading="lazy" width="602" height="166" srcset="https://embee-research.ghost.io/content/images/size/w600/2023/04/image-293.png 600w, https://embee-research.ghost.io/content/images/2023/04/image-293.png 602w"></figure><figure class="kg-card kg-image-card"><img src="https://embee-research.ghost.io/content/images/2023/04/image-292.png" class="kg-image" alt="https://embee-research.ghost.io/content/images/2023/04/image-292.png" loading="lazy" width="491" height="125"></figure><p>As well as setting a breakpoint on the new address of the API resolving function.</p><figure class="kg-card kg-image-card"><img src="https://embee-research.ghost.io/content/images/2023/04/image-294.png" class="kg-image" alt="https://embee-research.ghost.io/content/images/2023/04/image-294.png" loading="lazy" width="539" height="112"></figure><p>Blobrunner can now be executed - Which will trigger a breakpoint on the start of the api resolving function <code>&lt;base&gt; + 0x73</code></p><figure class="kg-card kg-image-card"><img src="https://embee-research.ghost.io/content/images/2023/04/image-295.png" class="kg-image" alt="https://embee-research.ghost.io/content/images/2023/04/image-295.png" loading="lazy" width="1232" height="217" srcset="https://embee-research.ghost.io/content/images/size/w600/2023/04/image-295.png 600w, https://embee-research.ghost.io/content/images/size/w1000/2023/04/image-295.png 1000w, https://embee-research.ghost.io/content/images/2023/04/image-295.png 1232w" sizes="(min-width: 720px) 720px"></figure><p>Remember the hashed value contained the second argument <code>[esp+8]</code>. This is the first value that should be logged.,</p><figure class="kg-card kg-image-card"><img src="https://embee-research.ghost.io/content/images/2023/04/image-296.png" class="kg-image" alt="https://embee-research.ghost.io/content/images/2023/04/image-296.png" loading="lazy" width="1046" height="234" srcset="https://embee-research.ghost.io/content/images/size/w600/2023/04/image-296.png 600w, https://embee-research.ghost.io/content/images/size/w1000/2023/04/image-296.png 1000w, https://embee-research.ghost.io/content/images/2023/04/image-296.png 1046w" sizes="(min-width: 720px) 720px"></figure><p>We can go ahead and <code>EDIT</code> the breakpoint. Adding the following conditions.</p><ul><li>Log Text - <code>Hash: 0x{x:[esp+8]}</code> - This will log the hex value contained at <code>[esp+8]</code></li><li><code>Hash:</code>  this is just generic text for readability</li><li><code>0x</code> prepend a <code>0x</code> to each printed hex value</li><li><code>{x:[esp+8]}</code> - print the hex <code>x</code> representation of the value at <code>[esp+8]</code></li><li>Command Text - <code>run;</code> - this will continue execution instead of pausing at the breakpoint.</li></ul><p>The conditional breakpoint should look like the below screenshot.</p><figure class="kg-card kg-image-card"><img src="https://embee-research.ghost.io/content/images/2023/04/image-301.png" class="kg-image" alt="https://embee-research.ghost.io/content/images/2023/04/image-301.png" loading="lazy" width="1014" height="503" srcset="https://embee-research.ghost.io/content/images/size/w600/2023/04/image-301.png 600w, https://embee-research.ghost.io/content/images/size/w1000/2023/04/image-301.png 1000w, https://embee-research.ghost.io/content/images/2023/04/image-301.png 1014w" sizes="(min-width: 720px) 720px"></figure><p>Now when the Malware executes - Hashed values will be printed to the Log Window.</p><p>Next we’ll add a second breakpoint to log the decoded values.</p><figure class="kg-card kg-image-card"><img src="https://embee-research.ghost.io/content/images/2023/04/image-302.png" class="kg-image" alt="https://embee-research.ghost.io/content/images/2023/04/image-302.png" loading="lazy" width="961" height="590" srcset="https://embee-research.ghost.io/content/images/size/w600/2023/04/image-302.png 600w, https://embee-research.ghost.io/content/images/2023/04/image-302.png 961w" sizes="(min-width: 720px) 720px"></figure><p>Let's now take it a step further and print the decoded api names.</p><p>We can do this by restarting the program and recreating the initial conditional breakpoint.</p><p>A second conditional breakpoint will need to be created at the end of the Api hashing function <code>&lt;base&gt; +0xc9</code>.</p><figure class="kg-card kg-image-card"><img src="https://embee-research.ghost.io/content/images/2023/04/image-303.png" class="kg-image" alt="https://embee-research.ghost.io/content/images/2023/04/image-303.png" loading="lazy" width="1858" height="207" srcset="https://embee-research.ghost.io/content/images/size/w600/2023/04/image-303.png 600w, https://embee-research.ghost.io/content/images/size/w1000/2023/04/image-303.png 1000w, https://embee-research.ghost.io/content/images/size/w1600/2023/04/image-303.png 1600w, https://embee-research.ghost.io/content/images/2023/04/image-303.png 1858w" sizes="(min-width: 720px) 720px"></figure><p>Once the end of the api hashing function <code>&lt;base&gt; + 0xc9</code> has been located - A second conditional breakpoint can be created.</p><figure class="kg-card kg-image-card"><img src="https://embee-research.ghost.io/content/images/2023/04/image-304.png" class="kg-image" alt="https://embee-research.ghost.io/content/images/2023/04/image-304.png" loading="lazy" width="1405" height="365" srcset="https://embee-research.ghost.io/content/images/size/w600/2023/04/image-304.png 600w, https://embee-research.ghost.io/content/images/size/w1000/2023/04/image-304.png 1000w, https://embee-research.ghost.io/content/images/2023/04/image-304.png 1405w" sizes="(min-width: 720px) 720px"></figure><p>(Remembering that we want to log the api name at EAX, but not the actual value of EAX). This can be done by using <code>{a:eax}</code></p><figure class="kg-card kg-image-card"><img src="https://embee-research.ghost.io/content/images/2023/04/image-305.png" class="kg-image" alt="https://embee-research.ghost.io/content/images/2023/04/image-305.png" loading="lazy" width="2000" height="277" srcset="https://embee-research.ghost.io/content/images/size/w600/2023/04/image-305.png 600w, https://embee-research.ghost.io/content/images/size/w1000/2023/04/image-305.png 1000w, https://embee-research.ghost.io/content/images/size/w1600/2023/04/image-305.png 1600w, https://embee-research.ghost.io/content/images/size/w2400/2023/04/image-305.png 2400w" sizes="(min-width: 720px) 720px"></figure><p>The syntax of  <code>{a:eax}</code>  can be obtained from the x64dbg documentation -  this will print the address information which contains any relevant function names. (<a href="https://help.x64dbg.com/en/latest/introduction/Formatting.html?ref=embee-research.ghost.io">As per the x64dbg documentation</a>)</p><figure class="kg-card kg-image-card"><img src="https://embee-research.ghost.io/content/images/2023/04/image-306.png" class="kg-image" alt="https://embee-research.ghost.io/content/images/2023/04/image-306.png" loading="lazy" width="839" height="184" srcset="https://embee-research.ghost.io/content/images/size/w600/2023/04/image-306.png 600w, https://embee-research.ghost.io/content/images/2023/04/image-306.png 839w" sizes="(min-width: 720px) 720px"></figure><p>We can use this to set the following conditional breakpoint at the return address <code>&lt;base&gt; + 0xc9</code>.</p><figure class="kg-card kg-image-card"><img src="https://embee-research.ghost.io/content/images/2023/04/image-307.png" class="kg-image" alt="https://embee-research.ghost.io/content/images/2023/04/image-307.png" loading="lazy" width="1022" height="500" srcset="https://embee-research.ghost.io/content/images/size/w600/2023/04/image-307.png 600w, https://embee-research.ghost.io/content/images/size/w1000/2023/04/image-307.png 1000w, https://embee-research.ghost.io/content/images/2023/04/image-307.png 1022w" sizes="(min-width: 720px) 720px"></figure><p>Now when the Malware is executed - A list of hashes and their decoded values can be observed in the Log Window.</p><figure class="kg-card kg-image-card"><img src="https://embee-research.ghost.io/content/images/2023/04/image-308.png" class="kg-image" alt="https://embee-research.ghost.io/content/images/2023/04/image-308.png" loading="lazy" width="912" height="847" srcset="https://embee-research.ghost.io/content/images/size/w600/2023/04/image-308.png 600w, https://embee-research.ghost.io/content/images/2023/04/image-308.png 912w" sizes="(min-width: 720px) 720px"></figure><p>This information can be used to further markup a Ghidra database.</p><figure class="kg-card kg-image-card"><img src="https://embee-research.ghost.io/content/images/2023/04/image-309.png" class="kg-image" alt="https://embee-research.ghost.io/content/images/2023/04/image-309.png" loading="lazy" width="2000" height="465" srcset="https://embee-research.ghost.io/content/images/size/w600/2023/04/image-309.png 600w, https://embee-research.ghost.io/content/images/size/w1000/2023/04/image-309.png 1000w, https://embee-research.ghost.io/content/images/size/w1600/2023/04/image-309.png 1600w, https://embee-research.ghost.io/content/images/size/w2400/2023/04/image-309.png 2400w" sizes="(min-width: 720px) 720px"></figure><p>Alternatively - You can start adding breakpoints on future functionality of the Malware.</p><p>Eg Setting breakpoints on newly resolved api’s <code>ReadFile</code> , <code>VirtualAlloc</code> etc.</p><h2 id="auto-creating-breakpoints-on-hashed-api%E2%80%99s">Auto-creating breakpoints on Hashed API’s</h2><p>Additional breakpoints can be created manually eg <code>bp ReadFile</code> - but they can also be auto-created by modifying the command text to <code>bp eax; run;</code></p><figure class="kg-card kg-image-card"><img src="https://embee-research.ghost.io/content/images/2023/04/image-310.png" class="kg-image" alt="https://embee-research.ghost.io/content/images/2023/04/image-310.png" loading="lazy" width="2000" height="627" srcset="https://embee-research.ghost.io/content/images/size/w600/2023/04/image-310.png 600w, https://embee-research.ghost.io/content/images/size/w1000/2023/04/image-310.png 1000w, https://embee-research.ghost.io/content/images/size/w1600/2023/04/image-310.png 1600w, https://embee-research.ghost.io/content/images/2023/04/image-310.png 2383w" sizes="(min-width: 720px) 720px"></figure><p>The Malware will now automatically create and trigger breakpoints on any function that was resolved via api hashing.</p><p>Since API hashing is generally used to hide suspicious imports - each new breakpoint should reveal something of interest.</p><figure class="kg-card kg-image-card"><img src="https://embee-research.ghost.io/content/images/2023/04/image-311.png" class="kg-image" alt="https://embee-research.ghost.io/content/images/2023/04/image-311.png" loading="lazy" width="1580" height="199" srcset="https://embee-research.ghost.io/content/images/size/w600/2023/04/image-311.png 600w, https://embee-research.ghost.io/content/images/size/w1000/2023/04/image-311.png 1000w, https://embee-research.ghost.io/content/images/2023/04/image-311.png 1580w" sizes="(min-width: 720px) 720px"></figure><p>Here are some short examples of information gathered from newly auto-created breakpoints.</p><p><code>lStrCatW</code> - which appeared to be creating a folder path containing the final <code>djdqvq.sra</code> file from the original nullsoft folder.</p><p>Here is a copy of the original nullsoft folder.</p><figure class="kg-card kg-image-card"><img src="https://embee-research.ghost.io/content/images/2023/04/image-313.png" class="kg-image" alt="https://embee-research.ghost.io/content/images/2023/04/image-313.png" loading="lazy" width="1555" height="379" srcset="https://embee-research.ghost.io/content/images/size/w600/2023/04/image-313.png 600w, https://embee-research.ghost.io/content/images/size/w1000/2023/04/image-313.png 1000w, https://embee-research.ghost.io/content/images/2023/04/image-313.png 1555w" sizes="(min-width: 720px) 720px"></figure><p>Here are the two values being concatenated by <code>lstrcatW</code> - They combine to create <code>C:\\\\users\\\\&lt;user&gt;\\\\Appdata\\\\local\\\\temp\\\\djdqvq.sra</code></p><figure class="kg-card kg-image-card"><img src="https://embee-research.ghost.io/content/images/2023/04/image-312.png" class="kg-image" alt="https://embee-research.ghost.io/content/images/2023/04/image-312.png" loading="lazy" width="1607" height="518" srcset="https://embee-research.ghost.io/content/images/size/w600/2023/04/image-312.png 600w, https://embee-research.ghost.io/content/images/size/w1000/2023/04/image-312.png 1000w, https://embee-research.ghost.io/content/images/size/w1600/2023/04/image-312.png 1600w, https://embee-research.ghost.io/content/images/2023/04/image-312.png 1607w" sizes="(min-width: 720px) 720px"></figure><p>This would make a good hunting IOC if you discovered this malware sample in your environment.</p><p><code>PathAppendW</code> - Revealed an interesting path for an exe file. <code>c:\\\\users\\\\&lt;user&gt;\\\\appdata\\\\roaming\\\\eirbw\\\\gcluqa.exe</code></p><figure class="kg-card kg-image-card"><img src="https://embee-research.ghost.io/content/images/2023/04/image-314.png" class="kg-image" alt="https://embee-research.ghost.io/content/images/2023/04/image-314.png" loading="lazy" width="1582" height="479" srcset="https://embee-research.ghost.io/content/images/size/w600/2023/04/image-314.png 600w, https://embee-research.ghost.io/content/images/size/w1000/2023/04/image-314.png 1000w, https://embee-research.ghost.io/content/images/2023/04/image-314.png 1582w" sizes="(min-width: 720px) 720px"></figure><p>After a few more api calls related to persistence (via run key) and the creation of that <code>eirbw</code> folder.</p><p>An attempt was made to open the <code>djdqvq.sra</code> file via <code>CreateFileW</code></p><figure class="kg-card kg-image-card"><img src="https://embee-research.ghost.io/content/images/2023/04/image-315.png" class="kg-image" alt="https://embee-research.ghost.io/content/images/2023/04/image-315.png" loading="lazy" width="1558" height="486" srcset="https://embee-research.ghost.io/content/images/size/w600/2023/04/image-315.png 600w, https://embee-research.ghost.io/content/images/size/w1000/2023/04/image-315.png 1000w, https://embee-research.ghost.io/content/images/2023/04/image-315.png 1558w" sizes="(min-width: 720px) 720px"></figure><p>To keep the Malware happy and avoid patching memory - I copied the <code>djdqvq.sra</code> file to the <code>c:\\\\users\\\\&lt;user&gt;\\\\appdata\\\\local\\temp</code> folder.</p><figure class="kg-card kg-image-card"><img src="https://embee-research.ghost.io/content/images/2023/04/image-316.png" class="kg-image" alt="https://embee-research.ghost.io/content/images/2023/04/image-316.png" loading="lazy" width="1415" height="198" srcset="https://embee-research.ghost.io/content/images/size/w600/2023/04/image-316.png 600w, https://embee-research.ghost.io/content/images/size/w1000/2023/04/image-316.png 1000w, https://embee-research.ghost.io/content/images/2023/04/image-316.png 1415w" sizes="(min-width: 720px) 720px"></figure><p>The Malware was then allowed to continue to execute - at which point it hit another call to  <code>VirtualAlloc</code> .</p><p><code>Execute Until Return</code> was used obtain the resulting buffer in <code>EAX</code>, and then a hardware breakpoint was created to observe it’s contents.</p><figure class="kg-card kg-image-card"><img src="https://embee-research.ghost.io/content/images/2023/04/image-317.png" class="kg-image" alt="https://embee-research.ghost.io/content/images/2023/04/image-317.png" loading="lazy" width="2000" height="651" srcset="https://embee-research.ghost.io/content/images/size/w600/2023/04/image-317.png 600w, https://embee-research.ghost.io/content/images/size/w1000/2023/04/image-317.png 1000w, https://embee-research.ghost.io/content/images/size/w1600/2023/04/image-317.png 1600w, https://embee-research.ghost.io/content/images/size/w2400/2023/04/image-317.png 2400w" sizes="(min-width: 720px) 720px"></figure><p>The <code>ReadFile</code> api is then triggered (via auto-created breakpoint) - and the contents of the <code>djdqvq.sra</code> file are loaded into memory in the buffer created by<code>VirtualAlloc</code> .</p><p>Here we can see the <code>djdqvq.sra</code> contents in a hex editor.</p><figure class="kg-card kg-image-card"><img src="https://embee-research.ghost.io/content/images/2023/04/image-319.png" class="kg-image" alt="https://embee-research.ghost.io/content/images/2023/04/image-319.png" loading="lazy" width="1287" height="313" srcset="https://embee-research.ghost.io/content/images/size/w600/2023/04/image-319.png 600w, https://embee-research.ghost.io/content/images/size/w1000/2023/04/image-319.png 1000w, https://embee-research.ghost.io/content/images/2023/04/image-319.png 1287w" sizes="(min-width: 720px) 720px"></figure><p>Observing the memory buffer reveals identical contents - confirming that this is <code>djdqvq.sra</code></p><figure class="kg-card kg-image-card"><img src="https://embee-research.ghost.io/content/images/2023/04/image-318.png" class="kg-image" alt="https://embee-research.ghost.io/content/images/2023/04/image-318.png" loading="lazy" width="1591" height="701" srcset="https://embee-research.ghost.io/content/images/size/w600/2023/04/image-318.png 600w, https://embee-research.ghost.io/content/images/size/w1000/2023/04/image-318.png 1000w, https://embee-research.ghost.io/content/images/2023/04/image-318.png 1591w" sizes="(min-width: 720px) 720px"></figure><p>This data is likely encrypted - The Entropy graph is extremely high in detect-it-easy.</p><figure class="kg-card kg-image-card"><img src="https://embee-research.ghost.io/content/images/2023/04/image-320.png" class="kg-image" alt="https://embee-research.ghost.io/content/images/2023/04/image-320.png" loading="lazy" width="1516" height="1072" srcset="https://embee-research.ghost.io/content/images/size/w600/2023/04/image-320.png 600w, https://embee-research.ghost.io/content/images/size/w1000/2023/04/image-320.png 1000w, https://embee-research.ghost.io/content/images/2023/04/image-320.png 1516w" sizes="(min-width: 720px) 720px"></figure><p>The Malware was allowed to continue execution. This was in hopes that it would trigger another hardware breakpoint during the decoding of the encrypted content.</p><p>After continuing (and clicking continue through a few exceptions) - the first byte <code>49</code> is turned into a promising <code>4D</code> , the first half of an MZ  <code>4D 5A</code>  header.</p><figure class="kg-card kg-image-card"><img src="https://embee-research.ghost.io/content/images/2023/04/image-321.png" class="kg-image" alt="https://embee-research.ghost.io/content/images/2023/04/image-321.png" loading="lazy" width="1588" height="612" srcset="https://embee-research.ghost.io/content/images/size/w600/2023/04/image-321.png 600w, https://embee-research.ghost.io/content/images/size/w1000/2023/04/image-321.png 1000w, https://embee-research.ghost.io/content/images/2023/04/image-321.png 1588w" sizes="(min-width: 720px) 720px"></figure><p>The Malware can be allowed to finish decoding using <code>Execute Until Return</code>.</p><p><code>Execute Until Return</code> will work, but can be slow. An alternative is to set a breakpoint on the next <code>call</code> instruction after the triggering of the hardware breakpoint.</p><p>In this case, the next call was 2 instructions after the initial hardware breakpoint was triggered.</p><figure class="kg-card kg-image-card"><img src="https://embee-research.ghost.io/content/images/2023/04/image-322.png" class="kg-image" alt="https://embee-research.ghost.io/content/images/2023/04/image-322.png" loading="lazy" width="1935" height="601" srcset="https://embee-research.ghost.io/content/images/size/w600/2023/04/image-322.png 600w, https://embee-research.ghost.io/content/images/size/w1000/2023/04/image-322.png 1000w, https://embee-research.ghost.io/content/images/size/w1600/2023/04/image-322.png 1600w, https://embee-research.ghost.io/content/images/2023/04/image-322.png 1935w" sizes="(min-width: 720px) 720px"></figure><p>Once this breakpoint was triggered - a full PE file could be observed in the memory buffer.</p><figure class="kg-card kg-image-card"><img src="https://embee-research.ghost.io/content/images/2023/04/image-323.png" class="kg-image" alt="https://embee-research.ghost.io/content/images/2023/04/image-323.png" loading="lazy" width="1586" height="616" srcset="https://embee-research.ghost.io/content/images/size/w600/2023/04/image-323.png 600w, https://embee-research.ghost.io/content/images/size/w1000/2023/04/image-323.png 1000w, https://embee-research.ghost.io/content/images/2023/04/image-323.png 1586w" sizes="(min-width: 720px) 720px"></figure><p>The PE File can be saved to disk using <code>Follow in Memory map</code> and <code>Dump Memory To File</code>.</p><figure class="kg-card kg-image-card"><img src="https://embee-research.ghost.io/content/images/2023/04/image-324.png" class="kg-image" alt="https://embee-research.ghost.io/content/images/2023/04/image-324.png" loading="lazy" width="840" height="819" srcset="https://embee-research.ghost.io/content/images/size/w600/2023/04/image-324.png 600w, https://embee-research.ghost.io/content/images/2023/04/image-324.png 840w" sizes="(min-width: 720px) 720px"></figure><p>I saved the file as <code>unpacked.bin</code></p><h2 id="analysis-of-unpackedbin"><strong>Analysis of unpacked.bin</strong></h2><p>This unpacked.bin file was a 248KB PE - without any recognized packers or obfuscation.</p><figure class="kg-card kg-image-card"><img src="https://embee-research.ghost.io/content/images/2023/04/image-325.png" class="kg-image" alt="https://embee-research.ghost.io/content/images/2023/04/image-325.png" loading="lazy" width="1446" height="919" srcset="https://embee-research.ghost.io/content/images/size/w600/2023/04/image-325.png 600w, https://embee-research.ghost.io/content/images/size/w1000/2023/04/image-325.png 1000w, https://embee-research.ghost.io/content/images/2023/04/image-325.png 1446w" sizes="(min-width: 720px) 720px"></figure><p>Based on the entropy graph - there were no glaring signs of hidden encrypted files or content.</p><figure class="kg-card kg-image-card"><img src="https://embee-research.ghost.io/content/images/2023/04/image-326.png" class="kg-image" alt="https://embee-research.ghost.io/content/images/2023/04/image-326.png" loading="lazy" width="1519" height="1315" srcset="https://embee-research.ghost.io/content/images/size/w600/2023/04/image-326.png 600w, https://embee-research.ghost.io/content/images/size/w1000/2023/04/image-326.png 1000w, https://embee-research.ghost.io/content/images/2023/04/image-326.png 1519w" sizes="(min-width: 720px) 720px"></figure><p>Reviewing the imported functions - there was a suspicious reference to <code>CLRCreateInstance</code>. This is typical when a file contains an embedded .NET payload.</p><figure class="kg-card kg-image-card"><img src="https://embee-research.ghost.io/content/images/2023/04/image-327.png" class="kg-image" alt="https://embee-research.ghost.io/content/images/2023/04/image-327.png" loading="lazy" width="2000" height="1068" srcset="https://embee-research.ghost.io/content/images/size/w600/2023/04/image-327.png 600w, https://embee-research.ghost.io/content/images/size/w1000/2023/04/image-327.png 1000w, https://embee-research.ghost.io/content/images/size/w1600/2023/04/image-327.png 1600w, https://embee-research.ghost.io/content/images/2023/04/image-327.png 2129w" sizes="(min-width: 720px) 720px"></figure><p>I loaded the file into Ghidra and checked x-refs (cross references) to <code>CLRCreateInstance</code>. The api was called only once from the function <code>FUN_00401000</code>.</p><figure class="kg-card kg-image-card"><img src="https://embee-research.ghost.io/content/images/2023/04/image-328.png" class="kg-image" alt="https://embee-research.ghost.io/content/images/2023/04/image-328.png" loading="lazy" width="1323" height="478" srcset="https://embee-research.ghost.io/content/images/size/w600/2023/04/image-328.png 600w, https://embee-research.ghost.io/content/images/size/w1000/2023/04/image-328.png 1000w, https://embee-research.ghost.io/content/images/2023/04/image-328.png 1323w" sizes="(min-width: 720px) 720px"></figure><p><code>CLRCreateInstance</code> is called only once from the function <code>FUN_00401000</code> -  which itself is only called once from <code>FUN_0040147b</code>.</p><p>The function <code>FUN_0040147b</code> that eventually calls <code>CLRCreateInstance</code>, is responsible for loading an embedded resource and passing it to the <code>CLRCreateInstance</code> function.</p><p>Below you can see references to <code>FindResourceW</code> and <code>LoadResource</code> - prior to calling the function which contains <code>CLRCreateInstance</code></p><figure class="kg-card kg-image-card"><img src="https://embee-research.ghost.io/content/images/2023/04/image-330.png" class="kg-image" alt="https://embee-research.ghost.io/content/images/2023/04/image-330.png" loading="lazy" width="1567" height="1079" srcset="https://embee-research.ghost.io/content/images/size/w600/2023/04/image-330.png 600w, https://embee-research.ghost.io/content/images/size/w1000/2023/04/image-330.png 1000w, https://embee-research.ghost.io/content/images/2023/04/image-330.png 1567w" sizes="(min-width: 720px) 720px"></figure><p>Checking the <code>unpacked.bin</code> file using resource hacker. An embedded pe file can be observed in the resource section.</p><p>Since this resource is not encrypted or obfuscated - this explains why there were no signs of embedded content in the Entropy Graph.</p><figure class="kg-card kg-image-card"><img src="https://embee-research.ghost.io/content/images/2023/04/image-331.png" class="kg-image" alt="https://embee-research.ghost.io/content/images/2023/04/image-331.png" loading="lazy" width="2000" height="939" srcset="https://embee-research.ghost.io/content/images/size/w600/2023/04/image-331.png 600w, https://embee-research.ghost.io/content/images/size/w1000/2023/04/image-331.png 1000w, https://embee-research.ghost.io/content/images/size/w1600/2023/04/image-331.png 1600w, https://embee-research.ghost.io/content/images/2023/04/image-331.png 2002w" sizes="(min-width: 720px) 720px"></figure><p>Since the file was named resource <code>1</code> - I lazily saved the file as <code>1.bin</code>.</p><h2 id="analysis-of-the-final-stage"><strong>Analysis of The Final Stage</strong></h2><p>I again used detect-it-easy - which revealed the file was a .NET based program.</p><figure class="kg-card kg-image-card"><img src="https://embee-research.ghost.io/content/images/2023/04/image-332.png" class="kg-image" alt="https://embee-research.ghost.io/content/images/2023/04/image-332.png" loading="lazy" width="1440" height="917" srcset="https://embee-research.ghost.io/content/images/size/w600/2023/04/image-332.png 600w, https://embee-research.ghost.io/content/images/size/w1000/2023/04/image-332.png 1000w, https://embee-research.ghost.io/content/images/2023/04/image-332.png 1440w" sizes="(min-width: 720px) 720px"></figure><p>No significant areas of high entropy - but a large flat section that may contain something interesting and/or badly obfuscated.</p><figure class="kg-card kg-image-card"><img src="https://embee-research.ghost.io/content/images/2023/04/image-333.png" class="kg-image" alt="https://embee-research.ghost.io/content/images/2023/04/image-333.png" loading="lazy" width="1522" height="1252" srcset="https://embee-research.ghost.io/content/images/size/w600/2023/04/image-333.png 600w, https://embee-research.ghost.io/content/images/size/w1000/2023/04/image-333.png 1000w, https://embee-research.ghost.io/content/images/2023/04/image-333.png 1522w" sizes="(min-width: 720px) 720px"></figure><p> <code>1.bin</code> was loaded into Dnspy for additional analysis.</p><p>Dnspy revealed a lot of obfuscation and functions that were difficult to analyse,</p><figure class="kg-card kg-image-card"><img src="https://embee-research.ghost.io/content/images/2023/04/image-334.png" class="kg-image" alt="https://embee-research.ghost.io/content/images/2023/04/image-334.png" loading="lazy" width="2000" height="791" srcset="https://embee-research.ghost.io/content/images/size/w600/2023/04/image-334.png 600w, https://embee-research.ghost.io/content/images/size/w1000/2023/04/image-334.png 1000w, https://embee-research.ghost.io/content/images/size/w1600/2023/04/image-334.png 1600w, https://embee-research.ghost.io/content/images/size/w2400/2023/04/image-334.png 2400w" sizes="(min-width: 720px) 720px"></figure><p>It would be possible to analyse this obfuscation and manually rename each function, but that process is extremely tedious and time consuming.</p><p>Instead, I decided to use a tool called <a href="https://github.com/WithSecureLabs/GarbageMan/?ref=embee-research.ghost.io">Garbageman</a>. (<a href="https://github.com/WithSecureLabs/GarbageMan/releases/tag/v0.2.4?ref=embee-research.ghost.io">Download Link Here</a>)</p><p>Garbageman is a tool that can run a .NET program, and automatically capture strings and byte arrays that were created in memory.</p><blockquote>TLDR: You can run .NET Malware and easily obtain strings, embedded payloads and (if you're lucky) C2 information.</blockquote><p>Garbageman can be downloaded from the release page and then transferred into an analysis machine.</p><figure class="kg-card kg-image-card"><img src="https://embee-research.ghost.io/content/images/2023/04/image-336.png" class="kg-image" alt="https://embee-research.ghost.io/content/images/2023/04/image-336.png" loading="lazy" width="2000" height="798" srcset="https://embee-research.ghost.io/content/images/size/w600/2023/04/image-336.png 600w, https://embee-research.ghost.io/content/images/size/w1000/2023/04/image-336.png 1000w, https://embee-research.ghost.io/content/images/size/w1600/2023/04/image-336.png 1600w, https://embee-research.ghost.io/content/images/size/w2400/2023/04/image-336.png 2400w" sizes="(min-width: 720px) 720px"></figure><p>From here the release can be unzipped as a regular zip file.</p><p>(Note that 7-zip failed to unzip on my analysis machine, but the built in unzip tool worked just fine -  <code>right click -&gt; open with -&gt; windows explorer</code>  to unzip with the regular windows zip handler.</p><figure class="kg-card kg-image-card"><img src="https://embee-research.ghost.io/content/images/2023/04/image-337.png" class="kg-image" alt="https://embee-research.ghost.io/content/images/2023/04/image-337.png" loading="lazy" width="1157" height="586" srcset="https://embee-research.ghost.io/content/images/size/w600/2023/04/image-337.png 600w, https://embee-research.ghost.io/content/images/size/w1000/2023/04/image-337.png 1000w, https://embee-research.ghost.io/content/images/2023/04/image-337.png 1157w" sizes="(min-width: 720px) 720px"></figure><p>This will create a folder containing <code>Garbageman.exe</code></p><figure class="kg-card kg-image-card"><img src="https://embee-research.ghost.io/content/images/2023/04/image-338.png" class="kg-image" alt="https://embee-research.ghost.io/content/images/2023/04/image-338.png" loading="lazy" width="1513" height="791" srcset="https://embee-research.ghost.io/content/images/size/w600/2023/04/image-338.png 600w, https://embee-research.ghost.io/content/images/size/w1000/2023/04/image-338.png 1000w, https://embee-research.ghost.io/content/images/2023/04/image-338.png 1513w" sizes="(min-width: 720px) 720px"></figure><h2 id="running-garbageman">Running Garbageman</h2><p>Garbageman can be run by directly executing the <code>Garbageman.exe</code> file.</p><p>To run a suspicious file using Garbageman,  <code>File -&gt; New -&gt; Execute</code></p><figure class="kg-card kg-image-card"><img src="https://embee-research.ghost.io/content/images/2023/04/image-339.png" class="kg-image" alt="https://embee-research.ghost.io/content/images/2023/04/image-339.png" loading="lazy" width="1121" height="563" srcset="https://embee-research.ghost.io/content/images/size/w600/2023/04/image-339.png 600w, https://embee-research.ghost.io/content/images/size/w1000/2023/04/image-339.png 1000w, https://embee-research.ghost.io/content/images/2023/04/image-339.png 1121w" sizes="(min-width: 720px) 720px"></figure><p>The full path to <code>1.bin</code> will need to be specified in the executable option.</p><p>Most of the remaining options can largely be run as default - with a few changes…</p><ul><li>Increase the snapshots to <code>5</code></li><li>Set the interval to <code>200ms</code>.</li></ul><p>This will create 5 snapshots - at 500ms, 700ms, 900ms, 1100ms and 1300ms.</p><p>The exact timings don’t matter - but it is ideal to get multiple snapshots from the first 1-2 seconds of execution.</p><p>Once this is set - you can select “Start”</p><figure class="kg-card kg-image-card"><img src="https://embee-research.ghost.io/content/images/2023/04/image-340.png" class="kg-image" alt="https://embee-research.ghost.io/content/images/2023/04/image-340.png" loading="lazy" width="774" height="791" srcset="https://embee-research.ghost.io/content/images/size/w600/2023/04/image-340.png 600w, https://embee-research.ghost.io/content/images/2023/04/image-340.png 774w" sizes="(min-width: 720px) 720px"></figure><p>This will run the tool and capture relevant snapshots. After which a menu like this will be presented.,</p><p>This admittedly looks confusing - but for the most part - only the bottom left corner is important.</p><p>The bottom left corner is what allows you to search and view content that was captured in the snapshots.</p><figure class="kg-card kg-image-card"><img src="https://embee-research.ghost.io/content/images/2023/04/image-341.png" class="kg-image" alt="https://embee-research.ghost.io/content/images/2023/04/image-341.png" loading="lazy" width="2000" height="1005" srcset="https://embee-research.ghost.io/content/images/size/w600/2023/04/image-341.png 600w, https://embee-research.ghost.io/content/images/size/w1000/2023/04/image-341.png 1000w, https://embee-research.ghost.io/content/images/size/w1600/2023/04/image-341.png 1600w, https://embee-research.ghost.io/content/images/size/w2400/2023/04/image-341.png 2400w" sizes="(min-width: 720px) 720px"></figure><p>I recommend the following options as a starting point.</p><ul><li>Snapshot = Any - Search all available snapshots</li><li>Type = Byte or String - Show only bytes or strings</li><li>Value = Blank - Add additional filters later.</li><li>Order By = Address - This Groups similar content together (Change to size when looking for embedded payloads)</li><li>Limit = 1000 (or infinite) - Display as much data as possible</li><li>Order = Asc - Start from the "beginning" of the file. (Setto Desc if hunting for large content)</li></ul><figure class="kg-card kg-image-card"><img src="https://embee-research.ghost.io/content/images/2023/04/image-342.png" class="kg-image" alt="https://embee-research.ghost.io/content/images/2023/04/image-342.png" loading="lazy" width="1807" height="748" srcset="https://embee-research.ghost.io/content/images/size/w600/2023/04/image-342.png 600w, https://embee-research.ghost.io/content/images/size/w1000/2023/04/image-342.png 1000w, https://embee-research.ghost.io/content/images/size/w1600/2023/04/image-342.png 1600w, https://embee-research.ghost.io/content/images/2023/04/image-342.png 1807w" sizes="(min-width: 720px) 720px"></figure><p>The initial results are fairly benign, and there are lots of duplicates.</p><p>But there is an interesting User Agent Header and reference to <a href="http://apify.org/?ref=embee-research.ghost.io">apify.org</a>.</p><figure class="kg-card kg-image-card"><img src="https://embee-research.ghost.io/content/images/2023/04/image-343.png" class="kg-image" alt="https://embee-research.ghost.io/content/images/2023/04/image-343.png" loading="lazy" width="1767" height="425" srcset="https://embee-research.ghost.io/content/images/size/w600/2023/04/image-343.png 600w, https://embee-research.ghost.io/content/images/size/w1000/2023/04/image-343.png 1000w, https://embee-research.ghost.io/content/images/size/w1600/2023/04/image-343.png 1600w, https://embee-research.ghost.io/content/images/2023/04/image-343.png 1767w" sizes="(min-width: 720px) 720px"></figure><p>and then a pretty interesting reference to a yandex email address. This is something pretty unique and specific and worth googling.</p><figure class="kg-card kg-image-card"><img src="https://embee-research.ghost.io/content/images/2023/04/image-344.png" class="kg-image" alt="https://embee-research.ghost.io/content/images/2023/04/image-344.png" loading="lazy" width="1820" height="414" srcset="https://embee-research.ghost.io/content/images/size/w600/2023/04/image-344.png 600w, https://embee-research.ghost.io/content/images/size/w1000/2023/04/image-344.png 1000w, https://embee-research.ghost.io/content/images/size/w1600/2023/04/image-344.png 1600w, https://embee-research.ghost.io/content/images/2023/04/image-344.png 1820w" sizes="(min-width: 720px) 720px"></figure><h2 id="identification-of-agenttesla"><strong>Identification of AgentTesla</strong></h2><p>Googling the email address contained in the dump - numerous references to Malware are immediately shown.</p><figure class="kg-card kg-image-card"><img src="https://embee-research.ghost.io/content/images/2023/04/image-345.png" class="kg-image" alt="https://embee-research.ghost.io/content/images/2023/04/image-345.png" loading="lazy" width="1887" height="1485" srcset="https://embee-research.ghost.io/content/images/size/w600/2023/04/image-345.png 600w, https://embee-research.ghost.io/content/images/size/w1000/2023/04/image-345.png 1000w, https://embee-research.ghost.io/content/images/size/w1600/2023/04/image-345.png 1600w, https://embee-research.ghost.io/content/images/2023/04/image-345.png 1887w" sizes="(min-width: 720px) 720px"></figure><p>The first link is a <a href="https://triage.hatching.io/230410-pf13hsba5w?ref=embee-research.ghost.io">triage report</a> for AgentTesla. In an IR situation - this could be a good hint as to the malware family involved.</p><figure class="kg-card kg-image-card"><img src="https://embee-research.ghost.io/content/images/2023/04/image-346.png" class="kg-image" alt="https://embee-research.ghost.io/content/images/2023/04/image-346.png" loading="lazy" width="2000" height="801" srcset="https://embee-research.ghost.io/content/images/size/w600/2023/04/image-346.png 600w, https://embee-research.ghost.io/content/images/size/w1000/2023/04/image-346.png 1000w, https://embee-research.ghost.io/content/images/size/w1600/2023/04/image-346.png 1600w, https://embee-research.ghost.io/content/images/2023/04/image-346.png 2112w" sizes="(min-width: 720px) 720px"></figure><p>The Triage report contains an extracted malware config - with values very similar to what was found in Garbageman.</p><figure class="kg-card kg-image-card"><img src="https://embee-research.ghost.io/content/images/2023/04/image-347.png" class="kg-image" alt="https://embee-research.ghost.io/content/images/2023/04/image-347.png" loading="lazy" width="2000" height="635" srcset="https://embee-research.ghost.io/content/images/size/w600/2023/04/image-347.png 600w, https://embee-research.ghost.io/content/images/size/w1000/2023/04/image-347.png 1000w, https://embee-research.ghost.io/content/images/size/w1600/2023/04/image-347.png 1600w, https://embee-research.ghost.io/content/images/2023/04/image-347.png 2051w" sizes="(min-width: 720px) 720px"></figure><p>(The Malware also contains references to SMTP and port 587)</p><figure class="kg-card kg-image-card"><img src="https://embee-research.ghost.io/content/images/2023/04/image-348.png" class="kg-image" alt="https://embee-research.ghost.io/content/images/2023/04/image-348.png" loading="lazy" width="1766" height="605" srcset="https://embee-research.ghost.io/content/images/size/w600/2023/04/image-348.png 600w, https://embee-research.ghost.io/content/images/size/w1000/2023/04/image-348.png 1000w, https://embee-research.ghost.io/content/images/size/w1600/2023/04/image-348.png 1600w, https://embee-research.ghost.io/content/images/2023/04/image-348.png 1766w" sizes="(min-width: 720px) 720px"></figure><p>At this point some interesting information had been found, and it is ideal to try and hone in and establish more context.</p><p>To simplify the output and reduce duplicates. The search can be reduced to a single snapshot. (Any snapshot containing useful information can be used, and you should experiment with multiple snapshots)</p><p>Snapshot 4 was used for this case.</p><figure class="kg-card kg-image-card"><img src="https://embee-research.ghost.io/content/images/2023/04/image-349.png" class="kg-image" alt="https://embee-research.ghost.io/content/images/2023/04/image-349.png" loading="lazy" width="1830" height="1264" srcset="https://embee-research.ghost.io/content/images/size/w600/2023/04/image-349.png 600w, https://embee-research.ghost.io/content/images/size/w1000/2023/04/image-349.png 1000w, https://embee-research.ghost.io/content/images/size/w1600/2023/04/image-349.png 1600w, https://embee-research.ghost.io/content/images/2023/04/image-349.png 1830w" sizes="(min-width: 720px) 720px"></figure><p>With duplicates removed - there are references to Discord, Webmail, Facebook, and Twitter.</p><figure class="kg-card kg-image-card"><img src="https://embee-research.ghost.io/content/images/2023/04/image-350.png" class="kg-image" alt="https://embee-research.ghost.io/content/images/2023/04/image-350.png" loading="lazy" width="1820" height="642" srcset="https://embee-research.ghost.io/content/images/size/w600/2023/04/image-350.png 600w, https://embee-research.ghost.io/content/images/size/w1000/2023/04/image-350.png 1000w, https://embee-research.ghost.io/content/images/size/w1600/2023/04/image-350.png 1600w, https://embee-research.ghost.io/content/images/2023/04/image-350.png 1820w" sizes="(min-width: 720px) 720px"></figure><p>Reviewing the second result from the previous Google search (<a href="https://asec.ahnlab.com/en/51274/?ref=embee-research.ghost.io">Ahnsec Labs</a>)  - There is a suggestion that AgentTesla uses SMTP as a means of exfiltration and command and control.</p><p>This suggests that the discovered email address is the C2 of the file. The blog also suggests that the value <code>ubd*</code> found alongside the email address, is actually the password to the smtp server.</p><figure class="kg-card kg-image-card"><img src="https://embee-research.ghost.io/content/images/2023/04/image-351.png" class="kg-image" alt="https://embee-research.ghost.io/content/images/2023/04/image-351.png" loading="lazy" width="1670" height="385" srcset="https://embee-research.ghost.io/content/images/size/w600/2023/04/image-351.png 600w, https://embee-research.ghost.io/content/images/size/w1000/2023/04/image-351.png 1000w, https://embee-research.ghost.io/content/images/size/w1600/2023/04/image-351.png 1600w, https://embee-research.ghost.io/content/images/2023/04/image-351.png 1670w" sizes="(min-width: 720px) 720px"></figure><p>At this point in the analysis - I would have strong confidence that the sample was AgentTesla.</p><p>FoAnalysisonal confirmation. I scrolled down until more interesting unique and attack-related strings could be found.</p><p>This revealed some strings related to targeted applications.</p><figure class="kg-card kg-image-card"><img src="https://embee-research.ghost.io/content/images/2023/04/image-352.png" class="kg-image" alt="https://embee-research.ghost.io/content/images/2023/04/image-352.png" loading="lazy" width="1808" height="722" srcset="https://embee-research.ghost.io/content/images/size/w600/2023/04/image-352.png 600w, https://embee-research.ghost.io/content/images/size/w1000/2023/04/image-352.png 1000w, https://embee-research.ghost.io/content/images/size/w1600/2023/04/image-352.png 1600w, https://embee-research.ghost.io/content/images/2023/04/image-352.png 1808w" sizes="(min-width: 720px) 720px"></figure><p>A quick Google search reveals numerous results (<a href="https://www.splunk.com/en_us/blog/security/inside-the-mind-of-a-rat-agent-tesla-detection-and-analysis.html?ref=embee-research.ghost.io">Including Splunk</a>) for Agent Tesla malware.</p><p><code>intext:"iridium browser"  intext:amigo intext:brave intext:torch malware</code></p><figure class="kg-card kg-image-card"><img src="https://embee-research.ghost.io/content/images/2023/04/image-353.png" class="kg-image" alt="https://embee-research.ghost.io/content/images/2023/04/image-353.png" loading="lazy" width="1502" height="1520" srcset="https://embee-research.ghost.io/content/images/size/w600/2023/04/image-353.png 600w, https://embee-research.ghost.io/content/images/size/w1000/2023/04/image-353.png 1000w, https://embee-research.ghost.io/content/images/2023/04/image-353.png 1502w" sizes="(min-width: 720px) 720px"></figure><p>At this point - I was happy to consider the Malware as AgentTesla. And the C2 information to be successfully discovered.</p><figure class="kg-card kg-image-card"><img src="https://embee-research.ghost.io/content/images/2023/04/image-355.png" class="kg-image" alt="https://embee-research.ghost.io/content/images/2023/04/image-355.png" loading="lazy" width="1415" height="483" srcset="https://embee-research.ghost.io/content/images/size/w600/2023/04/image-355.png 600w, https://embee-research.ghost.io/content/images/size/w1000/2023/04/image-355.png 1000w, https://embee-research.ghost.io/content/images/2023/04/image-355.png 1415w" sizes="(min-width: 720px) 720px"></figure><p><strong>Conclusion</strong></p><p>That concludes this post. I've intentionally tried to cover as many topics as possible in order to demonstrate some useful analysis techniques. Hopefully, you've been able to learn something new.</p><p>If you enjoy these posts and want to support the creation of more. Consider signing up for the site.</p><p><strong>Resources</strong></p><ul><li>Hardware Breakpoints - <a href="https://reverseengineering.stackexchange.com/questions/28045/what-is-hardware-breakpoint-and-when-we-need-to-use-it?ref=embee-research.ghost.io">https://reverseengineering.stackexchange.com/questions/28045/what-is-hardware-breakpoint-and-when-we-need-to-use-it</a></li><li>x64dbg Documentation -String Formatting - <a href="https://help.x64dbg.com/en/latest/introduction/Formatting.html?ref=embee-research.ghost.io">https://help.x64dbg.com/en/latest/introduction/Formatting.html</a></li><li>GarbageMan - Download - <a href="https://github.com/WithSecureLabs/GarbageMan/?ref=embee-research.ghost.io">https://github.com/WithSecureLabs/GarbageMan/</a></li><li>GarbageMan - Website - <a href="https://labs.withsecure.com/tools/garbageman?ref=embee-research.ghost.io">https://labs.withsecure.com/tools/garbageman</a></li><li>Triage Report - Agent Tesla - <a href="https://triage.hatching.io/230410-pf13hsba5w?ref=embee-research.ghost.io">https://triage.hatching.io/230410-pf13hsba5w</a></li><li>Ahnsec Labs - Agent Tesla - <a href="https://asec.ahnlab.com/en/51274/?ref=embee-research.ghost.io">https://asec.ahnlab.com/en/51274/</a></li></ul>
        </section>

    </article>


</main>


        <section class="gh-container is-grid gh-outer">
            <div class="gh-container-inner gh-inner">
                <h2 class="gh-container-title">Read more</h2>
                <div class="gh-feed">
                        <article class="gh-card post no-image">
    <a class="gh-card-link" href="/threat-intel-queries-with-fofabot/">
            <figure class="gh-card-image">
                <img
                    srcset="/content/images/size/w160/format/webp/2024/01/2024-01-01-22_11_37-FOFA-Search-Engine.png 160w,
                            /content/images/size/w320/format/webp/2024/01/2024-01-01-22_11_37-FOFA-Search-Engine.png 320w,
                            /content/images/size/w600/format/webp/2024/01/2024-01-01-22_11_37-FOFA-Search-Engine.png 600w,
                            /content/images/size/w960/format/webp/2024/01/2024-01-01-22_11_37-FOFA-Search-Engine.png 960w,
                            /content/images/size/w1200/format/webp/2024/01/2024-01-01-22_11_37-FOFA-Search-Engine.png 1200w,
                            /content/images/size/w2000/format/webp/2024/01/2024-01-01-22_11_37-FOFA-Search-Engine.png 2000w"
                    sizes="320px"
                    src="/content/images/size/w600/2024/01/2024-01-01-22_11_37-FOFA-Search-Engine.png"
                    alt="Practical Queries for Identifying Malware Infrastructure With FOFA"
                    loading="lazy"
                >
            </figure>
        <div class="gh-card-wrapper">
            <h3 class="gh-card-title is-title">Practical Queries for Identifying Malware Infrastructure With FOFA</h3>
                <p class="gh-card-excerpt is-body">Identifying malware infrastructure with the FOFA scanner.</p>
            <footer class="gh-card-meta"><!--
             -->                    <time class="gh-card-date" datetime="2024-01-01">Jan 1, 2024</time>
                <!--
         --></footer>
        </div>
    </a>
</article>                        <article class="gh-card post no-image">
    <a class="gh-card-link" href="/ghidra-basics-shellcode-analysis/">
            <figure class="gh-card-image">
                <img
                    srcset="/content/images/size/w160/format/webp/2023/11/Shellcode-Analysis-With-Ghidra--1-.png 160w,
                            /content/images/size/w320/format/webp/2023/11/Shellcode-Analysis-With-Ghidra--1-.png 320w,
                            /content/images/size/w600/format/webp/2023/11/Shellcode-Analysis-With-Ghidra--1-.png 600w,
                            /content/images/size/w960/format/webp/2023/11/Shellcode-Analysis-With-Ghidra--1-.png 960w,
                            /content/images/size/w1200/format/webp/2023/11/Shellcode-Analysis-With-Ghidra--1-.png 1200w,
                            /content/images/size/w2000/format/webp/2023/11/Shellcode-Analysis-With-Ghidra--1-.png 2000w"
                    sizes="320px"
                    src="/content/images/size/w600/2023/11/Shellcode-Analysis-With-Ghidra--1-.png"
                    alt="Ghidra Basics - Manual Shellcode Analysis and C2 Extraction"
                    loading="lazy"
                >
            </figure>
        <div class="gh-card-wrapper">
            <h3 class="gh-card-title is-title">Ghidra Basics - Manual Shellcode Analysis and C2 Extraction</h3>
                <p class="gh-card-excerpt is-body">Manual analysis of Cobalt Strike Shellcode with Ghidra. Identifying function calls and resolving API hashing.</p>
            <footer class="gh-card-meta"><!--
             -->                    <time class="gh-card-date" datetime="2023-12-08">Dec 8, 2023</time>
                <!--
         --></footer>
        </div>
    </a>
</article>                        <article class="gh-card post no-image">
    <a class="gh-card-link" href="/ghidra-basics-identifying-and-decoding-encrypted-strings/">
            <figure class="gh-card-image">
                <img
                    srcset="/content/images/size/w160/format/webp/2023/12/Dealing-With-Encrypted-Strings-In-Ghidra.png 160w,
                            /content/images/size/w320/format/webp/2023/12/Dealing-With-Encrypted-Strings-In-Ghidra.png 320w,
                            /content/images/size/w600/format/webp/2023/12/Dealing-With-Encrypted-Strings-In-Ghidra.png 600w,
                            /content/images/size/w960/format/webp/2023/12/Dealing-With-Encrypted-Strings-In-Ghidra.png 960w,
                            /content/images/size/w1200/format/webp/2023/12/Dealing-With-Encrypted-Strings-In-Ghidra.png 1200w,
                            /content/images/size/w2000/format/webp/2023/12/Dealing-With-Encrypted-Strings-In-Ghidra.png 2000w"
                    sizes="320px"
                    src="/content/images/size/w600/2023/12/Dealing-With-Encrypted-Strings-In-Ghidra.png"
                    alt="Ghidra Basics - Identifying, Decoding and Fixing Encrypted Strings"
                    loading="lazy"
                >
            </figure>
        <div class="gh-card-wrapper">
            <h3 class="gh-card-title is-title">Ghidra Basics - Identifying, Decoding and Fixing Encrypted Strings</h3>
                <p class="gh-card-excerpt is-body">Manual identification, decryption and fixing of encrypted strings using Ghidra and x32dbg.</p>
            <footer class="gh-card-meta"><!--
             -->                    <time class="gh-card-date" datetime="2023-12-05">Dec 5, 2023</time>
                <!--
         --></footer>
        </div>
    </a>
</article>                        <article class="gh-card post no-image">
    <a class="gh-card-link" href="/advanced-threat-intel-queries-catching-83-qakbot-servers-with-regex-censys-and-tls-certificates/">
            <figure class="gh-card-image">
                <img
                    srcset="/content/images/size/w160/format/webp/2023/11/Advanced-Threat-Intel-Queries-With-Regular-Expressions.png 160w,
                            /content/images/size/w320/format/webp/2023/11/Advanced-Threat-Intel-Queries-With-Regular-Expressions.png 320w,
                            /content/images/size/w600/format/webp/2023/11/Advanced-Threat-Intel-Queries-With-Regular-Expressions.png 600w,
                            /content/images/size/w960/format/webp/2023/11/Advanced-Threat-Intel-Queries-With-Regular-Expressions.png 960w,
                            /content/images/size/w1200/format/webp/2023/11/Advanced-Threat-Intel-Queries-With-Regular-Expressions.png 1200w,
                            /content/images/size/w2000/format/webp/2023/11/Advanced-Threat-Intel-Queries-With-Regular-Expressions.png 2000w"
                    sizes="320px"
                    src="/content/images/size/w600/2023/11/Advanced-Threat-Intel-Queries-With-Regular-Expressions.png"
                    alt="Advanced Threat Intel Queries - Catching 83 Qakbot Servers with Regex, Censys and TLS Certificates"
                    loading="lazy"
                >
            </figure>
        <div class="gh-card-wrapper">
            <h3 class="gh-card-title is-title">Advanced Threat Intel Queries - Catching 83 Qakbot Servers with Regex, Censys and TLS Certificates</h3>
                <p class="gh-card-excerpt is-body">Catching 83 Qakbot Servers using Regular Expressions.</p>
            <footer class="gh-card-meta"><!--
             -->                    <time class="gh-card-date" datetime="2023-11-30">Nov 30, 2023</time>
                <!--
         --></footer>
        </div>
    </a>
</article>                </div>
            </div>
        </section>

    
    <footer class="gh-footer gh-outer">
    <div class="gh-footer-inner gh-inner">

        <div class="gh-footer-bar">
            <span class="gh-footer-logo is-title">
                    <img src="https://embee-research.ghost.io/content/images/2023/11/logo.svg-1.svg" alt="Embee Research">
            </span>
            <nav class="gh-footer-menu">
                <ul class="nav">
    <li class="nav-index"><a href="https://embee-research.ghost.io/index/">Index</a></li>
</ul>

            </nav>
            <div class="gh-footer-copyright">
                Powered by <a href="https://ghost.org/" target="_blank" rel="noopener">Ghost</a>
            </div>
        </div>
        
                <section class="gh-footer-signup">
                    <h2 class="gh-footer-signup-header is-title">
                        Free Malware Analysis Tutorials
                    </h2>
                    <p class="gh-footer-signup-subhead is-body">
                        Free Malware Tutorials. No ads. Unsubscribe anytime. 
                    </p>
                    <form class="gh-form" data-members-form>
    <input class="gh-form-input" type="email" placeholder="jamie@example.com" required data-members-email>
    <button class="gh-button" type="submit">
        <span><span>Subscribe</span> <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" fill="currentColor" viewBox="0 0 256 256"><path d="M224.49,136.49l-72,72a12,12,0,0,1-17-17L187,140H40a12,12,0,0,1,0-24H187L135.51,64.48a12,12,0,0,1,17-17l72,72A12,12,0,0,1,224.49,136.49Z"></path></svg></span>
        <svg xmlns="http://www.w3.org/2000/svg" height="24" width="24" viewBox="0 0 24 24">
    <g stroke-linecap="round" stroke-width="2" fill="currentColor" stroke="none" stroke-linejoin="round" class="nc-icon-wrapper">
        <g class="nc-loop-dots-4-24-icon-o">
            <circle cx="4" cy="12" r="3"></circle>
            <circle cx="12" cy="12" r="3"></circle>
            <circle cx="20" cy="12" r="3"></circle>
        </g>
        <style data-cap="butt">
            .nc-loop-dots-4-24-icon-o{--animation-duration:0.8s}
            .nc-loop-dots-4-24-icon-o *{opacity:.4;transform:scale(.75);animation:nc-loop-dots-4-anim var(--animation-duration) infinite}
            .nc-loop-dots-4-24-icon-o :nth-child(1){transform-origin:4px 12px;animation-delay:-.3s;animation-delay:calc(var(--animation-duration)/-2.666)}
            .nc-loop-dots-4-24-icon-o :nth-child(2){transform-origin:12px 12px;animation-delay:-.15s;animation-delay:calc(var(--animation-duration)/-5.333)}
            .nc-loop-dots-4-24-icon-o :nth-child(3){transform-origin:20px 12px}
            @keyframes nc-loop-dots-4-anim{0%,100%{opacity:.4;transform:scale(.75)}50%{opacity:1;transform:scale(1)}}
        </style>
    </g>
</svg>        <svg class="checkmark" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 52 52">
    <path class="checkmark__check" fill="none" d="M14.1 27.2l7.1 7.2 16.7-16.8"/>
    <style>
        .checkmark {
            width: 40px;
            height: 40px;
            display: block;
            stroke-width: 2.5;
            stroke: currentColor;
            stroke-miterlimit: 10;
        }

        .checkmark__check {
            transform-origin: 50% 50%;
            stroke-dasharray: 48;
            stroke-dashoffset: 48;
            animation: stroke .3s cubic-bezier(0.650, 0.000, 0.450, 1.000) forwards;
        }

        @keyframes stroke {
            100% { stroke-dashoffset: 0; }
        }
    </style>
</svg>    </button>
</form>                </section>

    </div>
</footer>    
</div>

    <div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">
    <div class="pswp__bg"></div>

    <div class="pswp__scroll-wrap">
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <div class="pswp__ui pswp__ui--hidden">
            <div class="pswp__top-bar">
                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
                <button class="pswp__button pswp__button--share" title="Share"></button>
                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)"></button>
            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>
        </div>
    </div>
</div>
<script src="/assets/built/source.js?v=4b294bb165"></script>



</body>
</html>
